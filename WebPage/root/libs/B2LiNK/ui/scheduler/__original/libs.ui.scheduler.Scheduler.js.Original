(function(){

	//----------------------------------------------------------------------------------------------------;

	//	libs.ui.scheduler.Scheduler;

	//----------------------------------------------------------------------------------------------------;

	/**
	 * Scheduler
	 * @type {{ _seed : number }}
	 */
	Scheduler = {
		_seed : 0
		, scheduler : null
	};

	Scheduler.getSchedulerInstance = function()
	{
		var scheduler = {};

		/*** configure locale : ko ***/
		scheduler.locale = {
			date : {
				  month_full : [ "1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월" ]
				, month_short : [ "1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월" ]
				, day_full : [ "일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일" ]
				, day_short : [ "일", "월", "화", "수", "목", "금", "토" ]
			},
			labels : {
				sdr_cal_today_button : "오늘",
				day_tab : "일",
				week_tab : "주",
				month_tab : "월",
				year_tab : "년",
				new_event : "새 일정",
				icon_save : "저장",
				icon_cancel : "취소",
				icon_details : "자세히",
				icon_edit : "수정",
				icon_delete : "삭제",
				confirm_closing : "",//Your changes will be lost, are your sure ?
				confirm_deleting : "정말 삭제하시겠습니까?<br>일정을 삭제하면 복구할 수 없습니다!",
				section_description : "설명",
				section_time : "기간",
				full_day : "종일",

				//recurring events
				confirm_recurring : "반복되는 모든 일정을 수정하시겠습니까?",
				section_recurring : "반복 일정",
				button_recurring : "사용불가",
				button_recurring_open : "사용가능",
				button_edit_series : "반복 일정 수정",
				button_edit_occurrence : "일정 수정",

				//list view
				list_tab : "목록",
				date : "날짜",
				description : "설명",

				//touch tooltip
				drag_to_create : "드래그로 생성",
				drag_to_move : "드래그로 이동",

				//message default buttons
				message_ok : "확인",
				message_cancel : "취소"
			}
		};


		/* reference by scheduler.date.date_to_str
		 %e	Day of the month without leading zeros (01..31)
		 %d	Day of the month, 2 digits with leading zeros (01..31)
		 %j	Day of the year, 3 digits with leading zeros (001..366)
		 %a	A textual representation of a day, two letters
		 %W	A full textual representation of the day of the week

		 %c	Numeric representation of a month, without leading zeros (0..12)
		 %m	Numeric representation of a month, with leading zeros (00..12)
		 %b	A short textual representation of a month, three letters (Jan..Dec)
		 %M	A full textual representation of a month, such as January or March (January..December)

		 %y	A two digit representation of a year (93..03)
		 %Y	A full numeric representation of a year, 4 digits (1993..03)
		 */

		/*** configure config ***/
		scheduler.config = {
			default_date : "%Y년 %M %d일",
			year_date : "%Y년",
			month_date : "%Y년 %F",
			week_date : "%l",
			day_date : "%M %d일 %D",//"%D, %F %j",
			hour_date : "%H:%i",
			month_day : "%d",
			load_date : "%Y-%m-%d",
			xml_date : "%Y-%m-%d %H:%i",
			api_date : "%Y-%m-%d %H:%i",

			//use recurring
			repeat_date : "%Y.%m.%d",
			include_end_by : true,
			full_day : false,
			lightbox_recurring : "ask",//series, instance
			occurrence_timestamp_in_utc : true,
			recurring_workdays : [1,2,3,4,5],
			repeat_precise : true,
			limit_time_select : true,

			//list view range
			list_start : null,
			list_end : null,

			year_x : 4,
			year_y : 3,

			preserve_length : true,
			time_step : 5,
			start_on_monday : false,//true=sunday,false=monday
			first_hour : 0,//0~23
			last_hour : 24,
			reset_hour_year : 2017,

			////TODO : Real
			readonly : true,
			view_page : true,
			////TODO : Test
			//readonly : false,
			//view_page : true,

			drag_resize : true,
			drag_move : true,
			drag_create : true,
			dblclick_create : true,
			details_on_create : true,
			details_on_dblclick : true,
			edit_on_create : true,
			resize_month_events : false,
			resize_month_timed : false,

			cascade_event_display : false,
			cascade_event_count : 4,
			cascade_event_margin : 30,

			multi_day : true,
			multi_day_height_limit : 0,

			drag_lightbox : true,
			preserve_scroll : true,
			select : false,

			server_utc : false,
			touch : true,
			touch_tip : true,
			touch_drag : 500,
			quick_info_detached : true,

			positive_closing : false,

			drag_highlight : true,
			limit_drag_out : false,
			icons_edit : ["icon_save", "icon_cancel"],
			icons_select : ["icon_details", "icon_edit", "icon_delete"],
			buttons_left : ["sdr_save_btn", "sdr_cancel_btn"],
			buttons_right : ["sdr_delete_btn"],
			lightbox : {
				sections : [
					{name:"description", height:130, map_to:"text", type:"textarea", focus:true},
					{name:"recurring", type:"recurring", map_to:"rec_type", button:"recurring"},//use recurring
					{name:"time", height:72, type:"time", map_to:"auto"}
				]
			},
			highlight_displayed_event : true,
			left_border : false,

			ajax_error : "alert",//"ignore"|"console"
			prevent_cache : true,

			//use skin
			fix_tab_position : true,
			use_select_menu_space : true,
			wide_form : true,
			hour_size_px : 42,
			displayed_event_color : "#ff4a4a",
			displayed_event_text_color : "#ffef80",

			//tooltip
			//use_year_tooltip : true,
			use_month_tooltip : true
		};


		/*** configure xy ***/
		scheduler.xy = {
			year_top : 0,
			min_event_height : 40,
			scale_width : 50,
			scroll_width : 18,
			scale_height : 20,
			month_scale_height : 20,
			menu_width : 25,
			margin_top : 0,
			margin_left : 0,
			editor_width : 140,
			month_head_height : 22,

			//use skin
			lightbox_additional_height : 90,
			nav_height : 59,
			bar_height : 24
		};
		scheduler.keys = {
			edit_save : 13,//ENTER
			edit_cancel : 27//ESC
		};
		scheduler.__recurring_template = '<div class="sdr_form_repeat"> <form> <div class="sdr_repeat_left"> <label><input class="sdr_repeat_radio" type="radio" name="repeat" value="day" />매일</label><br /> <label><input class="sdr_repeat_radio" type="radio" name="repeat" value="week"/>매주</label><br /> <label><input class="sdr_repeat_radio" type="radio" name="repeat" value="month" checked />매월</label><br /> <label><input class="sdr_repeat_radio" type="radio" name="repeat" value="year" />매년</label> </div> <div class="sdr_repeat_divider"></div> <div class="sdr_repeat_center"> <div style="display:none;" id="sdr_repeat_day"> <label><input class="sdr_repeat_radio" type="radio" name="day_type" value="d"/>반복 주기</label><input class="sdr_repeat_text" type="text" name="day_count" value="1" />일<br /> <label><input class="sdr_repeat_radio" type="radio" name="day_type" checked value="w"/>주중 매일</label> </div> <div style="display:none;" id="sdr_repeat_week">반복 주기 <input class="sdr_repeat_text" type="text" name="week_count" value="1" />주 다음 요일:<br /> <table class="sdr_repeat_days"> <tr> <td> <label><input class="sdr_repeat_checkbox" type="checkbox" name="week_day" value="1" />월</label><br /> <label><input class="sdr_repeat_checkbox" type="checkbox" name="week_day" value="4" />목</label> </td> <td> <label><input class="sdr_repeat_checkbox" type="checkbox" name="week_day" value="2" />화</label><br /> <label><input class="sdr_repeat_checkbox" type="checkbox" name="week_day" value="5" />금</label> </td> <td> <label><input class="sdr_repeat_checkbox" type="checkbox" name="week_day" value="3" />수</label><br /> <label><input class="sdr_repeat_checkbox" type="checkbox" name="week_day" value="6" />토</label> </td> <td> <label><input class="sdr_repeat_checkbox" type="checkbox" name="week_day" value="0" />일</label><br /><br /> </td> </tr> </table> </div> <div id="sdr_repeat_month"> <label><input class="sdr_repeat_radio" type="radio" name="month_type" value="d"/>Repeat</label><input class="sdr_repeat_text" type="text" name="month_day" value="1" />day every<input class="sdr_repeat_text" type="text" name="month_count" value="1" />month<br /> <label><input class="sdr_repeat_radio" type="radio" name="month_type" checked value="w"/>On</label><input class="sdr_repeat_text" type="text" name="month_week2" value="1" /><select name="month_day2"><option value="1" selected >Monday<option value="2">Tuesday<option value="3">Wednesday<option value="4">Thursday<option value="5">Friday<option value="6">Saturday<option value="0">Sunday</select>every<input class="sdr_repeat_text" type="text" name="month_count2" value="1" />month<br /> </div> <div style="display:none;" id="sdr_repeat_year"> <label><input class="sdr_repeat_radio" type="radio" name="year_type" value="d"/>Every</label><input class="sdr_repeat_text" type="text" name="year_day" value="1" />day<select name="year_month"><option value="0" selected >January<option value="1">February<option value="2">March<option value="3">April<option value="4">May<option value="5">June<option value="6">July<option value="7">August<option value="8">September<option value="9">October<option value="10">November<option value="11">December</select>month<br /> <label><input class="sdr_repeat_radio" type="radio" name="year_type" checked value="w"/>On</label><input class="sdr_repeat_text" type="text" name="year_week2" value="1" /><select name="year_day2"><option value="1" selected >Monday<option value="2">Tuesday<option value="3">Wednesday<option value="4">Thursday<option value="5">Friday<option value="6">Saturday<option value="7">Sunday</select>of<select name="year_month2"><option value="0" selected >January<option value="1">February<option value="2">March<option value="3">April<option value="4">May<option value="5">June<option value="6">July<option value="7">August<option value="8">September<option value="9">October<option value="10">November<option value="11">December</select><br /> </div> </div> <div class="sdr_repeat_divider"></div> <div class="sdr_repeat_right"> <label><input class="sdr_repeat_radio" type="radio" name="end" checked/>No end date</label><br /> <label><input class="sdr_repeat_radio" type="radio" name="end" />After</label><input class="sdr_repeat_text" type="text" name="occurences_count" value="1" />occurrences<br /> <label><input class="sdr_repeat_radio" type="radio" name="end" />End by</label><input class="sdr_repeat_date" type="text" name="date_of_end" value="'+scheduler.config.repeat_date_of_end+'" /><br /> </div> </form> </div> <div style="clear:both"> </div>';

		Scheduler.componentEventable(scheduler);

		Scheduler.eventObject._detachDomEvent = function( e, t, i ){
			e.removeEventListener ? e.removeEventListener(t, i, !1) : e.detachEvent && e.detachEvent("on" + t, i);
		};

		/**
		 * scheduler init_once
		 * @private
		 */
		scheduler._init_once = function(){

			var oldSize = getWindowSize();

			scheduler._window_resize_event_handler = function(){
				var newSize = getWindowSize();
				//ie7-8 triggers "resize" when window's elements are resized, it messes container-autoresize extension
				//check if it's actually resized
				if( !equals(oldSize, newSize) ){
					clearTimeout(scheduler._resize_timer);
					scheduler._resize_timer = setTimeout(function(){
						if( scheduler.callEvent( "onSchedulerResize", []) ){
							scheduler.update_view();
							scheduler.callEvent( "onAfterSchedulerResize", [] );
						}
					}, 100);
				}
				oldSize = newSize;
			};

			Scheduler.eventObject._attachDomEvent(window, "resize", scheduler._window_resize_event_handler);

			function getWindowSize()
			{
				return { w : window.innerWidth || document.documentElement.clientWidth, h : window.innerHeight || document.documentElement.clientHeight };
			}

			function equals( a, b ){ return a.w === b.w && a.h === b.h; }

			//self reset function
			scheduler._init_once = function(){
			};
		};

		/**
		 * scheduler must be call this function
		 * @param id
		 * @param date
		 * @param mode
		 */
		scheduler.init = function( id, date, mode )
		{
			date = date || (scheduler._currentDate() );
			mode = mode || "month";

			if( this._obj) this.unset_actions();

			this._obj = (typeof id === "string") ? document.getElementById( id ) : id;

			//hook for skin
			if( this._skin_init) scheduler._skin_init();

			scheduler.date.init();

			this._els = [];
			this._quirks = (_isIE && document.compatMode === "BackCompat" );
			this._quirks7 = (_isIE && navigator.appVersion.indexOf("MSIE 8") === -1);

			this.get_elements();
			this.init_templates();
			this.set_actions();

			//this._init_once();//can not used for b2ker
			this._init_touch_events();

			this.set_sizes();

			scheduler.callEvent( 'onSchedulerReady', [] );
			this.setCurrentView(date, mode);
		};


		scheduler.set_sizes = function(){
			var w = this._x = this._obj.clientWidth - this.xy.margin_left;
			var h = this._y = this._obj.clientHeight - this.xy.margin_top;

			//not-table mode always has scroll - need to be fixed in future
			var scale_x = this._table_view ? 0 : (this.xy.scale_width + this.xy.scroll_width);
			var scale_s = this._table_view ? -1 : this.xy.scale_width;

			this.set_xy( this._els[ "sdr_cal_navline" ][ 0 ], w, this.xy.nav_height, 0, 0);
			this.set_xy( this._els["sdr_cal_header"][ 0 ], w - scale_x, this.xy.scale_height, scale_s, this.xy.nav_height + (this._quirks ? -1 : 1));
			//to support alter-skin, we need a way to alter height directly from css
			var actual_height = this._els[ "sdr_cal_navline" ][ 0 ].offsetHeight;
			if( actual_height > 0) this.xy.nav_height = actual_height;

			var data_y = this.xy.scale_height + this.xy.nav_height + (this._quirks ? -2 : 0);
			this.set_xy( this._els["sdr_cal_data"][ 0 ], w, h - (data_y + 2), 0, data_y + 2);
		};

		scheduler.set_xy = function( node, w, h, x, y )
		{
			node.style.width = Math.max(0, w) + "px";
			node.style.height = Math.max(0, h) + "px";
			if( arguments.length > 3 )
			{
				node.style.left = x + "px";
				node.style.top = y + "px";
			}
		};

		scheduler.get_elements = function()
		{
			//get all child elements as named hash;
			var els = this._obj.getElementsByTagName( "DIV" );
			for( var i=0; i<els.length; i++ )
			{
				var class_name = els[ i ].className || "";
				var attr_value = els[ i ].getAttribute("data-name") || "";
				if( class_name) class_name = class_name.split( " " )[ 0 ];
				if( !this._els[ class_name ] ) this._els[ class_name ] = [];
				this._els[ class_name ].push( els[ i ] );

				//check if name need to be changed
				var label = scheduler.locale.labels[attr_value || class_name];

				if( typeof label !== "string" && attr_value && !els[ i ].innerHTML)
					label = attr_value.split( "_" )[ 0 ];

				if( label) els[ i ].innerHTML = label;
			}
		};

		scheduler.unset_actions = function()
		{
			for( var a in this._els )
				if( this._click[ a ] )
					for( var i = 0; i < this._els[ a ].length; i++ )
						this._els[ a ][ i ].onclick = null;

			this._obj.onselectstart = null;
			this._obj.onmousemove = null;
			this._obj.onmousedown = null;
			this._obj.onmouseup = null;
			this._obj.ondblclick = null;
			this._obj.oncontextmenu = null;
		};

		scheduler.set_actions = function()
		{
			for( var a in this._els )
				if( this._click[ a ] )
					for( var i = 0; i < this._els[ a ].length; i++ )
						this._els[ a ][ i ].onclick = scheduler._click[ a ];

			this._obj.onselectstart = function( e ){ return false; };
			this._obj.onmousemove = function( e ){ if( !scheduler._temp_touch_block) scheduler._on_mouse_move(e || event); };
			this._obj.onmousedown = function( e ){ if( !scheduler._ignore_next_click) scheduler._on_mouse_down(e || event); };
			this._obj.onmouseup = function( e ){ if( !scheduler._ignore_next_click) scheduler._on_mouse_up(e || event); };
			this._obj.ondblclick = function( e ){ scheduler._on_dbl_click(e || event); };
			this._obj.oncontextmenu = function( e )
			{
				var ev = e || event;
				var src = ev.target || ev.srcElement;
				var returnValue = scheduler.callEvent( "onContextMenu", [scheduler._locate_event(src), ev] );
				return returnValue;
			};
		};

		scheduler.select = function( id )
		{
			if( this._select_id === id ) return;
			scheduler._close_not_saved();
			this.editStop( false );
			this.unselect();
			this._select_id = id;
			this.updateEvent( id );
		};

		scheduler.unselect = function( id )
		{
			if( id && id !== this._select_id) return;
			var t = this._select_id;
			this._select_id = null;
			if( t && this.getEvent( t )) this.updateEvent( t );
		};

		scheduler.getState = function()
		{
			return {
				mode : this._mode
				, date : new Date( this._date )
				, min_date : new Date(this._min_date)
				, max_date : new Date(this._max_date)
				, editor_id : this._edit_id
				, lightbox_id : this._lightbox_id
				, new_event : this._new_event
				, select_id : this._select_id
				, expanded : this.expanded
				, drag_id : this._drag_id
				, drag_mode : this._drag_mode
			};
		};
		scheduler._click = {
			sdr_cal_data : function( e ){
				//in case of touch disable click processing
				if( scheduler._ignore_next_click )
				{
					if( e.preventDefault ) e.preventDefault();
					e.cancelBubble = true;
					scheduler._ignore_next_click = false;
					return false;
				}

				var target = e ? e.target : event.srcElement;
				var id = scheduler._locate_event(target);

				e = e || event;

				if( id )
				{
					if( !scheduler.callEvent( "onClick", [id, e]) || (scheduler.config.readonly && !scheduler.config.view_page)) return;

					//window.JaceLog.log("scheduler._click.sdr_cal_data : id = " + id);

					var name = ( target.className || "" ).split( " " )[ 0 ];
					switch( name )
					{
						case "sdr_cal_event" :
						case "sdr_cal_event_line" :
						case "sdr_cal_event_clear" : if( scheduler.config.view_page ) scheduler.showModalPage( id ); break;
						default : break;
					}

					if( scheduler.config.select ){
						scheduler.select( id );
					}
					var mask = target.className;
					if( mask.indexOf("_icon") !== -1 ) scheduler._click.buttons[mask.split( " " )[ 1 ].replace("icon_", "")]( id );
				}
				else
				{
					scheduler.callEvent( "onEmptyClick", [scheduler.getActionData( e ).date, e] );

					scheduler._close_not_saved();
					if( new Date().valueOf() - (scheduler._new_event || 0) > 500 ) scheduler.unselect();
				}
			},
			sdr_cal_prev_button : function(){
				scheduler._click.sdr_cal_next_button(0, -1);
			},
			sdr_cal_next_button : function( dummy, step ){
				scheduler.setCurrentView(scheduler.date.add(scheduler.date[scheduler._mode + "_start"](scheduler._date), (step || 1), scheduler._mode));
			},
			sdr_cal_today_button : function(){
				if( scheduler.callEvent( "onBeforeTodayDisplayed", []) ){
					scheduler.setCurrentView(scheduler._currentDate() );
				}
			},
			sdr_cal_tab : function(){
				var name = this.getAttribute("data-name" );
				var mode = name.substring(0, name.search("_tab"));
				scheduler.setCurrentView(scheduler._date, mode);
			},
			buttons : {
				"delete" : function( id )
				{
					var c = scheduler.locale.labels.confirm_deleting;
					scheduler._component_confirm(c, scheduler.locale.labels.title_confirm_deleting, function(){ scheduler.deleteEvent( id ); });
				},
				"edit" : function( id ){ scheduler.edit( id ); },
				"save" : function( id ){ scheduler.editStop( true ); },
				"details" : function( id ){ if( scheduler.config.view_page ) scheduler.showModalPage( id ); else scheduler.showLightbox( id ); },
				"cancel" : function( id ){ scheduler.editStop( false ); }
			}
		};

		scheduler._component_confirm = function( message, title, callback ){
			if( !message ) return callback();
			var opts = { text : message };
			if( title ) opts.title = title;
			if( callback ) opts.callback = function( result ){ if( result ) callback(); };
			Scheduler.component.confirm(opts);
		};

		scheduler.addEventNow = function( start, end, e )
		{
			var base = {};
			if( start && start.constructor.toString().match(/object/i) !== null ){
				base = start;
				start = null;
			}

			var d = (this.config.event_duration || this.config.time_step) * 60000;
			if( !start) start = base.start_date || Math.round((scheduler._currentDate()).valueOf() / d) * d;
			var start_date = new Date( start );
			if( !end ){
				var start_hour = this.config.first_hour;
				if( start_hour > start_date.getHours() ){
					start_date.setHours(start_hour);
					start = start_date.valueOf();
				}
				end = start.valueOf() + d;
			}
			var end_date = new Date( end );

			//scheduler.addEventNow(new Date(), new Date()) + collision though get_visible events defect (such event was not retrieved)
			if( start_date.valueOf() === end_date.valueOf())
				end_date.setTime(end_date.valueOf() + d);

			base.start_date = base.start_date || start_date;
			base.end_date = base.end_date || end_date;
			base.text = base.text || this.locale.labels.new_event;
			base.id = this._drag_id = this.uid();
			this._drag_mode = "new-size";

			this._loading = true;
			this.addEvent(base);
			this.callEvent( "onEventCreated", [this._drag_id, e] );
			this._loading = false;

			this._drag_event = {};//dummy , to trigger correct event updating logic
			this._on_mouse_up( e );
		};

		scheduler._on_dbl_click = function( e, src ){
			src = src || (e.target || e.srcElement);
			//if( this.config.readonly && !this.config.view_page) return;
			if( this.config.readonly) return;

			var name = (src.className || "").split( " " )[ 0 ];
			//window.JaceLog.log("scheduler._on_dbl_click : name = " + name);
			switch( name ){
				//case "sdr_scale_holder":
				//case "sdr_scale_holder_now":
				//case "sdr_wa_day_data":
				case "sdr_month_body":
					if( this.config.readonly) return;

					if( !scheduler.config.dblclick_create) break;
					this.addEventNow(this.getActionData( e ).date, null, e);
					break;
				case "sdr_cal_event":
				//case "sdr_wa_ev_body":
				//case "sdr_grid_event":
				case "sdr_cal_event_line":
				case "sdr_cal_event_clear":
					var id = this._locate_event(src);

					if( this.config.view_page ){
						this.showModalPage( id );
					} else {
						if( !this.callEvent( "onDblClick", [id, e])) return;
						if( this.config.details_on_dblclick || this._table_view || !this.getEvent( id )._timed || !this.config.select)
							this.showLightbox( id );
						else
							this.edit( id );
					}
					break;
				//case "sdr_time_block":
				case "sdr_cal_container":
				case "sdr_list_line":
					return;
				default:
					if( this.config.readonly && !this.config.view_page) return;
					var t = this["dblclick_" + name];
					if( t ){
						t.call(this, e);
					}
					else {
						if( src.parentNode && src !== this)
							return scheduler._on_dbl_click(e, src.parentNode);
					}
					break;
			}
		};
		//column index by mouse x-coordinate
		scheduler._get_column_index = function( x_pos ){
			var column = 0;
			if( this._cols ){

				var width = 0;
				for( var i = 0; i < this._cols.length && !width; i++ ){
					width = this._cols[ i ];
				}

				column = (width) ? x_pos / width : 0;

				if( this._ignores ){
					for( var i = 0; i <= column; i++ ){
						if( this._ignores[ i ]) column++;
					}
				}
			}
			return column;
		};
		//transform mouse coordinates to day-time indexes of week based view
		scheduler._week_indexes_from_pos = function( pos ){
			//"get position" can be invoked before columns are loaded into the units view
			if( !this._cols ){
				return pos;
			} else {
				var column = this._get_column_index(pos.x);
				pos.x = Math.min(this._cols.length - 1, Math.max(0, Math.ceil(column) - 1));

				pos.y = Math.max(0, Math.ceil(pos.y * 60 / (this.config.time_step * this.config.hour_size_px)) - 1) + this.config.first_hour * (60 / this.config.time_step);
				return pos;
			}
		};

		scheduler._mouse_coords = function( ev ){
			var pos;
			var b = document.body;
			var d = document.documentElement;
			if( !_isIE && (ev.pageX || ev.pageY) ){
				pos = {
					x : ev.pageX,
					y : ev.pageY
				};
			} else {
				pos = {
					x : ev.clientX + (b.scrollLeft || d.scrollLeft || 0) - b.clientLeft,
					y : ev.clientY + (b.scrollTop || d.scrollTop || 0) - b.clientTop
				};
			}

			//apply layout
			pos.x -= Scheduler.util.getAbsoluteLeft(this._obj) + (this._table_view ? 0 : this.xy.scale_width);
			pos.y -= Scheduler.util.getAbsoluteTop(this._obj) + this.xy.nav_height + (this._dy_shift || 0) + this.xy.scale_height - this._els["sdr_cal_data"][ 0 ].scrollTop;
			pos.ev = ev;

			var handler = this["mouse_" + this._mode];
			if( handler)
				return handler.call(this, pos);

			//transform to date
			if( !this._table_view ){
				pos = this._week_indexes_from_pos(pos);
			} else {
				var column = this._get_column_index(pos.x);
				if( !this._cols || !this._colsS)//list/map views
					return pos;

				var dy;
				for( dy = 1; dy < this._colsS.heights.length; dy++ ){
					if( this._colsS.heights[dy] > pos.y) break;
				}

				pos.y = Math.ceil((Math.max(0, column) + Math.max(0, dy - 1) * 7) * 24 * 60 / this.config.time_step);

				if( scheduler._drag_mode || this._mode === "month")
					pos.y = (Math.max(0, Math.ceil(column) - 1) + Math.max(0, dy - 1) * 7) * 24 * 60 / this.config.time_step;

				//we care about ignored days only during event moving in month view
				if( this._drag_mode === "move" ){
					if( scheduler._ignores_detected && scheduler.config.preserve_length ){
						pos._ignores = true;
						//get real lengtn of event
						if( !this._drag_event._event_length ){
							this._drag_event._event_length = this._get_real_event_length(this._drag_event.start_date, this._drag_event.end_date, {
								x_step : 1,
								x_unit : "day"
							});
						}
					}
				}

				pos.x = 0;
			}
			return pos;
		};
		scheduler._close_not_saved = function(){
			if( new Date().valueOf() - (scheduler._new_event || 0) > 500 && scheduler._edit_id ){
				var c = scheduler.locale.labels.confirm_closing;

				scheduler._component_confirm(c, scheduler.locale.labels.title_confirm_closing, function(){
					scheduler.editStop(scheduler.config.positive_closing);
				});
				if( c ){
					this._drag_id = this._drag_pos = this._drag_mode = null;
				}
			}
		};
		scheduler._correct_shift = function( start, back ){
			start -= ((new Date(scheduler._min_date)).getTimezoneOffset() - (new Date( start )).getTimezoneOffset()) * 60000 * (back ? -1 : 1);
			return start;
		};

		scheduler._is_pos_changed = function( old_pos, new_pos ){
			function diff(old_val, new_val, acc ){
				return !!(Math.abs(old_val - new_val) > acc);
			}

			if( !(old_pos && this._drag_pos) ){
				return true;
			}
			var delay = 100,
				d_pos = 5;

			//start drag only if passed some time since mouse down, or if mouse position changed sufficiently
			return !!(!this._drag_pos.start || (+new Date() - this._drag_pos.start > delay) || diff(old_pos.x, new_pos.x, d_pos) || diff(old_pos.y, new_pos.y, d_pos));
		};

		scheduler._on_mouse_move = function( e ){
			if( this._drag_mode ){
				var pos = this._mouse_coords( e );
				if( pos.force_redraw || this._is_pos_changed(this._drag_pos, pos) ){
					var start, end;
					if( this._edit_id !== this._drag_id)
						this._close_not_saved();

					if( !this._drag_mode)
						return;

					this._drag_pos = pos;
					this._drag_pos.has_moved = true;

					if( this._drag_mode === "create" ){
						this._close_not_saved();
						this.unselect(this._select_id);
						this._loading = true;

						start = this._get_date_from_pos(pos).valueOf();

						if( !this._drag_start ){
							var res = this.callEvent( "onBeforeEventCreated", [e, this._drag_id] );
							if( !res)
								return;

							this._drag_start = start;
							return;
						}

						end = start;

						var start_date = new Date(this._drag_start);
						var end_date = new Date( end );
						if( (this._mode === "day" || this._mode === "week") &&
							(start_date.getHours() === end_date.getHours() &&
							start_date.getMinutes() === end_date.getMinutes()) ){
							end_date = new Date(this._drag_start + 1000);
						}

						this._drag_id = this.uid();
						this.addEvent(start_date, end_date, this.locale.labels.new_event, this._drag_id, pos.fields);

						this.callEvent( "onEventCreated", [this._drag_id, e] );
						this._loading = false;
						this._drag_mode = "new-size";
					}

					var ev = this.getEvent(this._drag_id);
					var obj;

					if( this._drag_mode === "move" ){
						start = this._min_date.valueOf() + (pos.y * this.config.time_step + pos.x * 24 * 60 - (scheduler._move_pos_shift || 0) ) * 60000;
						if( !pos.custom && this._table_view) start += this.date.time_part(ev.start_date) * 1000;
						start = this._correct_shift( start );

						if( pos._ignores && this.config.preserve_length && this._table_view ){
							if( this.matrix)
								obj = this.matrix[this._mode];
							obj = obj || {x_step : 1, x_unit : "day"};
							end = start * 1 + this._get_fictional_event_length(start, this._drag_event._event_length, obj);
						} else {
							end = ev.end_date.valueOf() - (ev.start_date.valueOf() - start);
						}
					} else {//resize
						start = ev.start_date.valueOf();
						end = ev.end_date.valueOf();
						if( this._table_view ){
							var resize_date = this._min_date.valueOf() + pos.y * this.config.time_step * 60000 + (pos.custom ? 0 : 24 * 60 * 60000);
							if( this._mode === "month" ){
								resize_date = this._correct_shift(resize_date, false);
								if( this._drag_from_start ){
									var day = 24 * 60 * 60000;
									if( resize_date <= scheduler.date.date_part(new Date(end + day - 1)).valueOf())//to get end time as 23:59:59 and then the day start
										start = resize_date - day;
								} else {
									end = resize_date;
								}
							} else {
								if( pos.resize_from_start)
									start = resize_date;
								else
									end = resize_date;
							}
						} else {
							end = this.date.date_part(new Date(ev.end_date.valueOf() - 1)).valueOf() + pos.y * this.config.time_step * 60000;
							this._els["sdr_cal_data"][ 0 ].style.cursor = "s-resize";
							if( this._mode === "week" || this._mode === "day")
								end = this._correct_shift( end );
						}
						if( this._drag_mode === "new-size" ){
							if( end <= this._drag_start ){
								var shift = pos.shift || ((this._table_view && !pos.custom) ? 24 * 60 * 60000 : 0);
								start = end - (pos.shift ? 0 : shift);
								end = this._drag_start + (shift || (this.config.time_step * 60000));
							} else {
								start = this._drag_start;
							}
						} else {
							if( end <= start)
								end = start + this.config.time_step * 60000;
						}
					}
					var new_end = new Date(end - 1);
					var new_start = new Date( start );
					//deny drag out of visible scheduler scale in timeline view
					if( scheduler.config.limit_drag_out &&
						(+new_start < +scheduler._min_date || +end > +scheduler._max_date) ){
						var duration = end - new_start;
						if( +new_start < +scheduler._min_date ){
							new_start = new Date(scheduler._min_date);
							end = new Date(+new_start + duration);
						} else {
							end = new Date(scheduler._max_date);
							new_start = new Date(+end - duration);
						}
						new_end = new Date(end - 1);
					}

					//fix event dates when resized to bottom of the column (day/week views)
					if( !this._table_view && !scheduler.config.all_timed &&
						((!scheduler._get_section_view() && pos.x !== this._get_event_sday({
							start_date : new Date( end ),
							end_date : new Date( end )
						})) || new Date( end ).getHours() >= this.config.last_hour) ){
						var duration = end - new_start;
						var day = this._min_date.valueOf() + (pos.x * 24 * 60) * 60000;
						end = scheduler.date.date_part(new Date( day ));
						end.setHours(this.config.last_hour);
						new_end = new Date(end - 1);
						if( this._drag_mode === "move" ){
							new_start = new Date(+end - duration);
						}
					}

					//prevent out-of-borders situation for day|week view
					if( this._table_view || (new_end.getDate() === new_start.getDate() && new_end.getHours() < this.config.last_hour) || scheduler._allow_dnd ){
						ev.start_date = new_start;
						ev.end_date = new Date( end );
						if( this.config.update_render ){
							var sx = scheduler._els["sdr_cal_data"][ 0 ].scrollTop;
							this.update_view();
							scheduler._els["sdr_cal_data"][ 0 ].scrollTop = sx;
						} else
							this.updateEvent(this._drag_id);
					}
					if( this._table_view ){
						this.for_rendered(this._drag_id, function( r ){
							r.className += " sdr_in_move";
						});
					}

					this.callEvent( "onEventDrag", [this._drag_id, this._drag_mode, e] );
				}
			} else {
				if( scheduler.checkEvent("onMouseMove") ){
					var id = this._locate_event(e.target || e.srcElement);
					this.callEvent( "onMouseMove", [id, e] );
				}
			}
		};
		scheduler._on_mouse_down = function( e, src ){
			//on Mac we do not get onmouseup event when clicking right mouse button leaving us in dnd state
			//let's ignore right mouse button then
			if( e.button === 2)
				return;

			if( this.config.readonly || this._drag_mode) return;
			src = src || (e.target || e.srcElement);
			var classname = src.className && src.className.split( " " )[ 0 ];

			switch( classname ){
				case "sdr_cal_event_line":
				case "sdr_cal_event_clear":
					if( this._table_view)
						this._drag_mode = "move";//item in table mode
					break;
				case "sdr_event_move":
					//case "sdr_wa_ev_body":
					this._drag_mode = "move";
					break;
				case "sdr_event_resize":
					this._drag_mode = "resize";
					if( (src.className || "").indexOf("sdr_event_resize_end") < 0 ){
						scheduler._drag_from_start = true;
					} else {
						scheduler._drag_from_start = false;
					}
					break;
				case "sdr_scale_holder":
				case "sdr_scale_holder_now":
				case "sdr_month_body":
				case "sdr_matrix_cell":
				case "sdr_marked_timespan":
					this._drag_mode = "create";
					break;
				case "":
					if( src.parentNode)
						return scheduler._on_mouse_down(e, src.parentNode);
					break;
				default:
					if( !scheduler.checkEvent("onMouseDown") || scheduler.callEvent( "onMouseDown", [classname]) ){
						if( src.parentNode && src !== this && classname !== "sdr_body" ){
							return scheduler._on_mouse_down(e, src.parentNode);
						}
					}
					this._drag_mode = null;
					this._drag_id = null;
					break;
			}
			if( this._drag_mode ){
				var id = this._locate_event(src);
				if( !this.config["drag_" + this._drag_mode] || !this.callEvent( "onBeforeDrag", [id, this._drag_mode, e]))
					this._drag_mode = this._drag_id = 0;
				else {
					this._drag_id = id;

					if( this._edit_id !== this._drag_id || (this._edit_id && this._drag_mode === "create"))
						this._close_not_saved();
					if( !this._drag_mode)
						return;

					this._drag_event = scheduler._lame_clone(this.getEvent(this._drag_id) || {});
					this._drag_pos = this._mouse_coords( e );
					this._drag_pos.start = +new Date();
				}
			}
			this._drag_start = null;
		};

		scheduler._get_private_properties = function( event ){
			var fields = {};
			for( var i in event ){
				if( i.indexOf("_") === 0 ){
					fields[ i ] = true;
				}
			}
			return fields;
		};

		scheduler._clear_temporary_properties = function( clean, flagged_event ){
			var initial = this._get_private_properties(clean);
			var current_state = this._get_private_properties(flagged_event);
			for( var i in current_state ){
				if( !initial[ i ] ){
					delete flagged_event[ i ];
				}
			}
		};

		scheduler._on_mouse_up = function( e ){
			if( e && e.button === 2 && scheduler.config.touch) return;
			if( this._drag_mode && this._drag_id ){
				this._els["sdr_cal_data"][ 0 ].style.cursor = "default";

				var drag_id = this._drag_id;
				var mode = this._drag_mode;
				var moved = !this._drag_pos || this._drag_pos.has_moved;

				var ev = this.getEvent(this._drag_id);
				if( moved && (this._drag_event._sdr_changed || !this._drag_event.start_date || ev.start_date.valueOf() !== this._drag_event.start_date.valueOf() || ev.end_date.valueOf() !== this._drag_event.end_date.valueOf()) ){
					var is_new = (this._drag_mode === "new-size" );
					if( !this.callEvent( "onBeforeEventChanged", [ev, e, is_new, this._drag_event]) ){
						if( is_new ){
							this.deleteEvent(ev.id, true);
						} else {
							this._drag_event._sdr_changed = false;
							this._clear_temporary_properties(ev, this._drag_event);
							scheduler._lame_copy(ev, this._drag_event);
							this.updateEvent(ev.id);
						}
					} else {
						this._drag_id = this._drag_mode = null;
						if( is_new && this.config.edit_on_create ){
							this.unselect();
							this._new_event = new Date();//timestamp of creation
							//if selection disabled - force lightbox usage
							if( this._table_view || this.config.details_on_create || !this.config.select ){
								scheduler.callEvent( "onDragEnd", [drag_id, mode, e] );
								return this.showLightbox(drag_id);
							}
							this._drag_pos = true;//set flag to trigger full redraw
							this._select_id = this._edit_id = drag_id;
						} else {
							if( !this._new_event ){
								this.callEvent( is_new ? "onEventAdded" : "onEventChanged", [drag_id, this.getEvent(drag_id)] );
							}
						}
					}
				}

				//redraw even if there is no real changes - necessary for correct positioning item after drag
				if( this._drag_pos && (this._drag_pos.has_moved || this._drag_pos === true) ){
					this.render_view_data();
				}

				scheduler.callEvent( "onDragEnd", [drag_id, mode, e] );
			}
			this._drag_id = null;
			this._drag_mode = null;
			this._drag_pos = null;
		};

		scheduler._trigger_dyn_loading = function(){
			if( this._load_mode && this._load() ){
				this._render_wait = true;
				return true;
			} else {
				return false;
			}
		};

		scheduler.isViewExists = function( mode ){
			return !!(scheduler[mode + "_view"] || (scheduler.date[mode + "_start"] && scheduler.templates[mode + "_date"] && scheduler.templates[mode + "_scale_date"]));
		};

		scheduler.update_view = function(){

			var view = this[this._mode + "_view"];
			if( view ){
				view( true );
			} else {
				this._reset_scale();
			}

			if( this._trigger_dyn_loading() ){
				return true;
			}
			this.render_view_data();
		};

		scheduler.updateView = function( date, mode ){
			date = date || this._date;
			mode = mode || this._mode;
			var sdr_cal_data = "sdr_cal_data";

			if( !this._mode ){
				this._obj.className += " sdr_scheduler_" + mode;
			} else {
				this._obj.className = this._obj.className.replace("sdr_scheduler_" + this._mode, "sdr_scheduler_" + mode);
			}

			var prev_scroll = (this._mode === mode && this.config.preserve_scroll) ? this._els[sdr_cal_data][ 0 ].scrollTop : false;//saving current scroll

			//hide old custom view
			if( this[this._mode + "_view"] && mode && this._mode !== mode)
				this[this._mode + "_view"]( false );

			this._close_not_saved();

			var sdr_multi_day = "sdr_multi_day";
			if( this._els[sdr_multi_day] ){
				this._els[sdr_multi_day][ 0 ].parentNode.removeChild( this._els[sdr_multi_day][ 0 ] );
				this._els[sdr_multi_day] = null;
			}

			this._mode = mode;
			this._date = date;
			this._table_view = (this._mode === "month" );

			this._dy_shift = 0;//correction for multiday section in week/day views

			var tabs = this._els["sdr_cal_tab"];
			//calendar can work without view tabs
			if( tabs ){
				for( var i = 0; i < tabs.length; i++ ){
					var name = tabs[ i ].className;
					name = name.replace(/ active/g, "" );
					if( tabs[ i ].getAttribute("data-name") === this._mode + "_tab" ){
						name = name + " active";
					}
					tabs[ i ].className = name;
				}
			}

			//show new view
			this.update_view();

			//if we are updating or working with the same view scrollTop should be saved
			if( typeof prev_scroll === "number" ){
				this._els[sdr_cal_data][ 0 ].scrollTop = prev_scroll;//restoring original scroll
			}

			//month tooltip
			if( this.config.use_month_tooltip ){
				if( mode === "month") scheduler._init_month_tooltip();
				else scheduler._removeMonthTooltip();
			}
		};

		scheduler.setCurrentView = function( date, mode ){
			if( !this.callEvent( "onBeforeViewChange", [this._mode, this._date, mode || this._mode, date || this._date])) return;
			this.updateView(date, mode);
			this.callEvent( "onViewChange", [this._mode, this._date] );
		};

		scheduler._render_x_header = function( i, left, d, h, offset_top ){
			offset_top = offset_top || 0;
			//header scale
			var head = document.createElement( "DIV" );
			head.className = "sdr_scale_bar";

			if( this.templates[this._mode + "_scalex_class"] ){
				//'_scalex_class' - timeline already have similar template, use the same name
				head.className += ' ' + this.templates[this._mode + "_scalex_class"]( d );
			}

			var width = this._cols[ i ] - 1;

			if( this._mode === "month" && i === 0 && this.config.left_border ){
				head.className += " sdr_scale_bar_border";
				left = left + 1;
			}
			this.set_xy(head, width, this.xy.scale_height - 2, left, offset_top);//-2 for border
			head.innerHTML = this.templates[this._mode + "_scale_date"](d, this._mode);
			h.appendChild(head);
		};

		scheduler._get_columns_num = function( from, to ){
			var count = 7;
			if( !scheduler._table_view ){
				var count_n = scheduler.date["get_" + scheduler._mode + "_end"];
				if( count_n) to = count_n(from);
				count = Math.round((to.valueOf() - from.valueOf()) / (1000 * 60 * 60 * 24));
			}
			return count;
		};

		scheduler._get_timeunit_start = function(){
			//start date of currently displayed time unit(day, week,...)
			return this.date[this._mode + "_start"](new Date(this._date.valueOf()));
		};

		scheduler._get_view_end = function(){
			var dd = this._get_timeunit_start();
			var ed = scheduler.date.add(dd, 1, this._mode);
			if( !scheduler._table_view ){
				var count_n = scheduler.date["get_" + scheduler._mode + "_end"];
				if( count_n) ed = count_n(dd);
			}
			return ed;
		};

		scheduler._calc_scale_sizes = function( width, from, to ){
			//calculates number of displayed columns(days/units/month view cols) and their widths
			var summ = width;//border delta
			var count = this._get_columns_num(from, to);

			this._process_ignores(from, count, "day", 1);
			var realcount = count - this._ignores_detected;

			for( var i = 0; i < count; i++ ){
				if( this._ignores[ i ] ){
					this._cols[ i ] = 0;
					realcount++;
				} else {
					this._cols[ i ] = Math.floor(summ / (realcount - i));
				}
				summ -= this._cols[ i ];
				this._colsS[ i ] = (this._cols[i - 1] || 0) + (this._colsS[i - 1] || (this._table_view ? 0 : this.xy.scale_width + 2));
			}
			this._colsS['col_length'] = count;

			this._colsS[count] = (this._cols[count - 1] + this._colsS[count - 1]) || 0;
		};

		scheduler._set_scale_col_size = function( div, width, left ){
			var c = this.config;
			this.set_xy(div, width - 1, c.hour_size_px * (c.last_hour - c.first_hour), left + this.xy.scale_width + 1, 0);//-1 for border
		};

		scheduler._render_scales = function( header, data_area ){
			//render columns in week/units view, or header in month view
			var sd = new Date(scheduler._min_date),
				ed = new Date(scheduler._max_date),
				today = this.date.date_part(scheduler._currentDate() );

			var summ = parseInt(header.style.width, 10);//border delta
			var d = new Date(this._min_date);
			var count = this._get_columns_num(sd, ed);
			this._calc_scale_sizes(summ, sd, ed);
			var left = 0;

			header.innerHTML = "";
			for( var i = 0; i < count; i++ ){
				if( !this._ignores[ i ] ){
					this._render_x_header(i, left, d, header);
				}
				if( !this._table_view ){
					var scales = document.createElement( "DIV" );
					var cls = "sdr_scale_holder";
					if( d.valueOf() === today.valueOf()) cls = "sdr_scale_holder_now";

					if( this._ignores_detected && this._ignores[ i ] ){
						cls += " sdr_scale_ignore";
					}

					scales.className = cls + " " + this.templates.week_date_class(d, today);

					this._set_scale_col_size(scales, this._cols[ i ], left);

					data_area.appendChild(scales);
					this.callEvent( "onScaleAdd", [scales, d] );
				}

				left += this._cols[ i ];
				d = this.date.add(d, 1, "day" );
				d = this.date.day_start( d );
			}
		};

		scheduler._reset_scale = function(){
			//current mode doesn't support scales
			//we mustn't call reset_scale for such modes, so it just to be sure
			if( !this.templates[this._mode + "_date"]) return;



			var h = this._els["sdr_cal_header"][ 0 ];
			var data_area = this._els["sdr_cal_data"][ 0 ];
			var c = this.config;

			h.innerHTML = "";
			//data_area.scrollTop = 0;//fix flickering in FF; makes IE8 flicker instead
			data_area.innerHTML = "";

			var str = ((c.readonly || (!c.drag_resize)) ? " sdr_resize_denied" : "") + ((c.readonly || (!c.drag_move)) ? " sdr_move_denied" : "" );
			data_area.className = "sdr_cal_data" + str;

			this._scales = {};
			this._cols = [];//store for data section
			this._colsS = {height : 0};
			this._dy_shift = 0;

			this.set_sizes();

			var d, sd, today;
			var dd = this._get_timeunit_start();
			var ed = scheduler._get_view_end();

			d = sd = this._table_view ? scheduler.date.week_start(dd) : dd;

			this._min_date = d;
			this._els["sdr_cal_date"][ 0 ].innerHTML = this.templates[this._mode + "_date"](dd, ed, this._mode);

			this._max_date = ed;
			scheduler._render_scales(h, data_area);

			if( this._table_view ){//month view
				this._reset_month_scale(data_area, dd, sd);
			} else {
				this._reset_hours_scale(data_area, dd, sd);
				if( c.multi_day ){
					var sdr_multi_day = "sdr_multi_day";

					if( this._els[sdr_multi_day] ){
						this._els[sdr_multi_day][ 0 ].parentNode.removeChild( this._els[sdr_multi_day][ 0 ] );
						this._els[sdr_multi_day] = null;
					}

					var navline = this._els[ "sdr_cal_navline" ][ 0 ];
					var top = navline.offsetHeight + this._els["sdr_cal_header"][ 0 ].offsetHeight + 1;

					var c1 = document.createElement( "DIV" );
					c1.className = sdr_multi_day;
					c1.style.visibility = "hidden";
					this.set_xy(c1, Math.max(this._colsS[this._colsS.col_length] + this.xy.scroll_width - 2, 0), 0, 0, top);//2 extra borders, sdr_header has -1 bottom margin
					data_area.parentNode.insertBefore(c1, data_area);

					var c2 = c1.cloneNode( true );
					c2.className = sdr_multi_day + "_icon";
					c2.style.visibility = "hidden";
					this.set_xy(c2, this.xy.scale_width, 0, 0, top);//sdr_header has -1 bottom margin

					c1.appendChild(c2);
					this._els[sdr_multi_day] = [c1, c2];
					this._els[sdr_multi_day][ 0 ].onclick = this._click.sdr_cal_data;
				}
			}
		};

		scheduler._reset_hours_scale = function( b, dd, sd ){
			var c = document.createElement( "DIV" );
			c.className = "sdr_scale_holder";

			var date = new Date(this.config.reset_hour_year, 0, 1, this.config.first_hour, 0, 0);
			for( var i = this.config.first_hour * 1; i < this.config.last_hour; i++ ){
				var cc = document.createElement( "DIV" );
				cc.className = "sdr_scale_hour";
				cc.style.height = this.config.hour_size_px - (this._quirks ? 0 : 1) + "px";
				var width = this.xy.scale_width;
				if( this.config.left_border ){
					width = width - 1;
					cc.className += " sdr_scale_hour_border";
				}
				cc.style.width = width + "px";
				cc.innerHTML = scheduler.templates.hour_scale(date);

				c.appendChild(cc);
				date = this.date.add(date, 1, "hour" );
			}
			b.appendChild(c);
			if( this.config.scroll_hour ){
				b.scrollTop = this.config.hour_size_px * (this.config.scroll_hour - this.config.first_hour);
			}
		};

		scheduler._currentDate = function(){
			if( scheduler.config.now_date ){
				return new Date(scheduler.config.now_date);
			}
			return new Date();
		};

		scheduler._process_ignores = function( sd, n, mode, step, preserve ){
			this._ignores = {};
			this._ignores_detected = 0;
			var ignore = scheduler["ignore_" + this._mode];

			if( ignore ){
				var ign_date = new Date( sd );
				for( var i = 0; i < n; i++ ){
					if( ignore(ign_date) ){
						this._ignores_detected += 1;
						this._ignores[ i ] = true;
						if( preserve)
							n++;
					}
					ign_date = scheduler.date.add(ign_date, step, mode);
					if( scheduler.date[mode + '_start'])
						ign_date = scheduler.date[mode + '_start'](ign_date);
				}
			}
		};

		scheduler._render_month_scale = function( div, dd/*month start*/, sd/*view start*/ ){
			//renders month view layout

			var ed = scheduler.date.add(dd, 1, "month"),
				view_start = new Date( sd );
			var cd = scheduler._currentDate();
			this.date.date_part(cd);
			this.date.date_part( sd );

			var rows = Math.ceil(Math.round((ed.valueOf() - sd.valueOf()) / (60 * 60 * 24 * 1000)) / 7);
			var tdcss = [];

			for( var i = 0; i <= 7; i++ ){
				var cell_width = ((this._cols[ i ] || 0) - 1);
				if( i === 0 && this.config.left_border ){
					cell_width = cell_width - 1;
				}
				tdcss[ i ] = " style='width:" + cell_width + "px;";
			}

			function getCellHeight(row ){
				var h = scheduler._colsS.height;
				if( scheduler._colsS.heights[row + 1] !== undefined ){
					h = scheduler._colsS.heights[row + 1] - (scheduler._colsS.heights[row] || 0);
				}
				return h;
			}

			var cellheight = 0;

			var html = "<table cellpadding='0' cellspacing='0'>";
			var rendered_dates = [];
			for( var i = 0; i < rows; i++ ){
				html += "<tr>";
				var row_height = Math.max(getCellHeight( i ) - scheduler.xy.month_head_height, 0);
				for( var j = 0; j < 7; j++ ){
					html += "<td";

					var cls = "";
					if( sd < dd)
						cls = "sdr_before";
					else if( sd >= ed)
						cls = "sdr_after";
					else if( sd.valueOf() === cd.valueOf())
						cls = "sdr_now";

					if( this._ignores_detected && this._ignores[ j ] ){
						cls += " sdr_scale_ignore";
					}

					html += " class='" + cls + " " + this.templates.month_date_class(sd, cd) + "' >";
					var body_class = "sdr_month_body";
					var head_class = "sdr_month_head";
					if( j === 0 && this.config.left_border ){
						body_class += " sdr_month_body_border";
						head_class += " sdr_month_head_border";
					}
					if( !this._ignores_detected || !this._ignores[ j ] ){
						html += "<div class='" + head_class + "'>" + this.templates.month_day( sd ) + "</div>";
						html += "<div class='" + body_class + "' " + tdcss[ j ] + ";height:" + row_height + "px;'></div></td>";
					} else {
						html += "<div></div><div></div>";
					}
					rendered_dates.push( sd );
					var bf1 = sd.getDate();
					sd = this.date.add(sd, 1, "day" );
					if( sd.getDate() - bf1 > 1 ){
						sd = new Date(sd.getFullYear(), sd.getMonth(), bf1 + 1, 12, 0);
					}
				}
				html += "</tr>";

				scheduler._colsS.heights[ i ] = cellheight;
				cellheight += getCellHeight( i );
			}
			html += "</table>";

			this._min_date = view_start;
			this._max_date = sd;

			div.innerHTML = html;

			this._scales = {};
			var divs = div.getElementsByTagName("div" );
			for( var i = 0; i < rendered_dates.length; i++ ){//[header, body, header, body, ...]
				var div = divs[(i * 2) + 1];
				var date = rendered_dates[ i ];
				this._scales[+date] = div;
			}
			for( var i = 0; i < rendered_dates.length; i++ ){
				var date = rendered_dates[ i ];
				this.callEvent( "onScaleAdd", [this._scales[+date], date] );
			}

			return this._max_date;
		};

		scheduler._reset_month_scale = function( b, dd, sd ){
			//recalculates rows height and redraws month layout
			var ed = scheduler.date.add(dd, 1, "month" );

			//trim time part for comparation reasons
			var cd = scheduler._currentDate();
			this.date.date_part(cd);
			this.date.date_part( sd );

			var rows = Math.ceil(Math.round((ed.valueOf() - sd.valueOf()) / (60 * 60 * 24 * 1000)) / 7);

			var height = (Math.floor(b.clientHeight / rows) - this.xy.month_head_height);

			this._colsS.height = height + this.xy.month_head_height;
			this._colsS.heights = [];

			return scheduler._render_month_scale(b, dd, sd);
		};

		scheduler.getLabel = function( property, key ){
			var sections = this.config.lightbox.sections;
			for( var i = 0; i < sections.length; i++ ){
				if( sections[ i ].map_to === property ){
					var options = sections[ i ].options;
					for( var j = 0; j < options.length; j++ ){
						if( options[ j ].key === key ){
							return options[ j ].label;
						}
					}
				}
			}
			return "";
		};

		scheduler._lame_clone = function( object, cache ){
			var i, t, result;//iterator, types array, result

			cache = cache || [];

			for( i = 0; i < cache.length; i += 2 ){
				if( object === cache[ i ] ){
					return cache[i + 1];
				}
			}

			if( object && typeof object === "object" ){
				result = {};
				t = [Array, Date, Number, String, Boolean];
				for( i = 0; i < t.length; i++ ){
					if( object instanceof t[ i ] ){
						result = i ? new t[ i ](object) : new t[ i ]();//first one is array
					}
				}
				cache.push(object, result);
				for( i in object ){
					if( Object.prototype.hasOwnProperty.apply(object, [ i ]) ){
						result[ i ] = scheduler._lame_clone(object[ i ], cache);
					}
				}
			}
			return result || object;
		};

		scheduler._lame_copy = function( target, source ){
			for( var key in source ){
				if( source.hasOwnProperty( key ) ){
					target[key] = source[key];
				}
			}
			return target;
		};

		scheduler._get_date_from_pos = function( pos ){
			var start = this._min_date.valueOf() + (pos.y * this.config.time_step + (this._table_view ? 0 : pos.x) * 24 * 60) * 60000;
			return new Date(this._correct_shift( start ));
		};

		scheduler.getActionData = function( n_ev ){
			var pos = this._mouse_coords(n_ev);
			return {
				date : this._get_date_from_pos(pos),
				section : pos.section
			};
		};

		scheduler._focus = function( node, select ){
			if( node && node.focus ){
				if( this.config.touch ){
					setTimeout(function(){
						node.focus();
					}, 100);
				} else {
					if( select && node.select) node.select();
					node.focus();
				}
			}
		};

		//non-linear scales
		scheduler._get_real_event_length = function( sd, fd, obj ){
			var ev_length = fd - sd;
			var hours = (obj._start_correction + obj._end_correction) || 0;
			var ignore = this["ignore_" + this._mode];

			var start_slot = 0,
				end_slot;

			if( obj.render ){
				start_slot = this._get_date_index(obj, sd);
				end_slot = this._get_date_index(obj, fd);
			} else {
				end_slot = Math.round(ev_length / 60 / 60 / 1000 / 24);
			}

			while( start_slot < end_slot ){
				var check = scheduler.date.add(fd, -obj.x_step, obj.x_unit);
				if( ignore && ignore(fd) ){
					ev_length -= (fd - check);
				} else {
					ev_length -= hours;
				}

				fd = check;
				end_slot--;
			}
			return ev_length;
		};

		scheduler._get_fictional_event_length = function( end_date, ev_length, obj, back ){
			var sd = new Date( end_date );
			var dir = back ? -1 : 1;

			//get difference caused by first|last hour
			if( obj._start_correction || obj._end_correction ){
				var today;
				if( back ){
					today = (sd.getHours() * 60 + sd.getMinutes()) - (obj.first_hour || 0) * 60;
				} else {
					today = (obj.last_hour || 0) * 60 - (sd.getHours() * 60 + sd.getMinutes() );
				}
				var per_day = (obj.last_hour - obj.first_hour) * 60;
				var days = Math.ceil((ev_length / (60 * 1000) - today ) / per_day);
				ev_length += days * (24 * 60 - per_day) * 60 * 1000;
			}

			var fd = new Date(end_date * 1 + ev_length * dir);
			var ignore = this["ignore_" + this._mode];

			var start_slot = 0,
				end_slot;
			if( obj.render ){
				start_slot = this._get_date_index(obj, sd);
				end_slot = this._get_date_index(obj, fd);
			} else {
				end_slot = Math.round(ev_length / 60 / 60 / 1000 / 24);
			}

			while( start_slot * dir <= end_slot * dir ){
				var check = scheduler.date.add(sd, obj.x_step * dir, obj.x_unit);
				if( ignore && ignore( sd ) ){
					ev_length += (check - sd) * dir;
					end_slot += dir;
				}

				sd = check;
				start_slot += dir;
			}

			return ev_length;
		};

		scheduler._get_section_view = function(){
			if( this.matrix && this.matrix[this._mode] ){
				return this.matrix[this._mode];
			} else if( this._props && this._props[this._mode] ){
				return this._props[this._mode];
			}
			return null;
		};

		scheduler._get_section_property = function(){
			if( this.matrix && this.matrix[this._mode] ){
				return this.matrix[this._mode].y_property;
			} else if( this._props && this._props[this._mode] ){
				return this._props[this._mode].map_to;
			}
			return null;
		};

		scheduler._is_initialized = function(){
			var state = this.getState();
			return (this._obj && state.date && state.mode);
		};

		scheduler._is_lightbox_open = function(){
			var state = this.getState();
			return state.lightbox_id !== null && state.lightbox_id !== undefined;
		};


		/*** scheduler date function ***/
		scheduler.date = {
			init : function(){
				var s = scheduler.locale.date.month_short;
				var t = scheduler.locale.date.month_short_hash = {};
				for( var i = 0; i < s.length; i++ ){
					t[s[ i ]] = i;
				}
				var s = scheduler.locale.date.month_full;
				var t = scheduler.locale.date.month_full_hash = {};
				for( var i = 0; i < s.length; i++ ){
					t[s[ i ]] = i;
				}
			},
			date_part : function( date ){
				var old = new Date(date);
				date.setHours( 0 );
				date.setMinutes( 0 );
				date.setSeconds( 0 );
				date.setMilliseconds( 0 );
				//shift to yesterday on dst
				if( date.getHours() && (date.getDate() < old.getDate() || date.getMonth() < old.getMonth() || date.getFullYear() < old.getFullYear()) ){
					date.setTime(date.getTime() + 60 * 60 * 1000 * (24 - date.getHours()));
				}
				return date;
			},
			time_part : function( date ){
				return (date.valueOf() / 1000 - date.getTimezoneOffset() * 60) % 86400;
			},
			week_start : function( date ){
				var shift = date.getDay();
				if( scheduler.config.start_on_monday ){
					if( shift === 0) shift = 6;
					else shift--;
				}
				return this.date_part(this.add(date, -1 * shift, "day"));
			},
			month_start : function( date ){
				date.setDate(1);
				return this.date_part(date);
			},
			year_start : function( date ){
				date.setMonth( 0 );
				return this.month_start(date);
			},
			day_start : function( date ){
				return this.date_part(date);
			},
			_add_days : function( date, inc ){
				var ndate = new Date(date.valueOf() );

				ndate.setDate(ndate.getDate() + inc);
				//shift to yesterday on dst
				if( inc >= 0 && (!date.getHours() && ndate.getHours()) && (ndate.getDate() < date.getDate() || ndate.getMonth() < date.getMonth() || ndate.getFullYear() < date.getFullYear()) ){
					ndate.setTime(ndate.getTime() + 60 * 60 * 1000 * (24 - ndate.getHours()));
				}
				return ndate;
			},
			add : function( date, inc, mode ){
				var ndate = new Date(date.valueOf() );
				switch( mode ){
					case "day":
						ndate = scheduler.date._add_days(ndate, inc);
						break;
					case "week":
						ndate = scheduler.date._add_days(ndate, inc * 7);
						break;
					case "month":
						ndate.setMonth(ndate.getMonth() + inc);
						break;
					case "year":
						ndate.setYear(ndate.getFullYear() + inc);
						break;
					case "hour":
						ndate.setTime(ndate.getTime() + inc * 60 * 60 * 1000);
						break;
					case "minute":
						ndate.setTime(ndate.getTime() + inc * 60 * 1000);
						break;
					default:
						return scheduler.date["add_" + mode](date, inc, mode);
				}
				return ndate;
			},
			to_fixed : function( num ){
				if( num < 10) return "0" + num;
				return num;
			},
			copy : function( date ){
				return new Date(date.valueOf() );
			},
			date_to_str : function( format, utc ){
				format = format.replace(/%[a-zA-Z]/g, function( a ){
					switch( a ){
						case "%d":
							return "\"+Scheduler.scheduler.date.to_fixed(date.getDate())+\"";
						case "%m":
							return "\"+Scheduler.scheduler.date.to_fixed((date.getMonth()+1))+\"";
						case "%j":
							return "\"+date.getDate()+\"";
						case "%n":
							return "\"+(date.getMonth()+1)+\"";
						case "%y":
							return "\"+Scheduler.scheduler.date.to_fixed(date.getFullYear()%100)+\"";
						case "%Y":
							return "\"+date.getFullYear()+\"";
						case "%D":
							return "\"+Scheduler.scheduler.locale.date.day_short[date.getDay()]+\"";
						case "%l":
							return "\"+Scheduler.scheduler.locale.date.day_full[date.getDay()]+\"";
						case "%M":
							return "\"+Scheduler.scheduler.locale.date.month_short[date.getMonth()]+\"";
						case "%F":
							return "\"+Scheduler.scheduler.locale.date.month_full[date.getMonth()]+\"";
						case "%h":
							return "\"+Scheduler.scheduler.date.to_fixed((date.getHours()+11)%12+1)+\"";
						case "%g":
							return "\"+((date.getHours()+11)%12+1)+\"";
						case "%G":
							return "\"+date.getHours()+\"";
						case "%H":
							return "\"+Scheduler.scheduler.date.to_fixed(date.getHours())+\"";
						case "%i":
							return "\"+Scheduler.scheduler.date.to_fixed(date.getMinutes())+\"";
						case "%a":
							return "\"+(date.getHours()>11?\"pm\":\"am\")+\"";
						case "%A":
							return "\"+(date.getHours()>11?\"PM\":\"AM\")+\"";
						case "%s":
							return "\"+Scheduler.scheduler.date.to_fixed(date.getSeconds())+\"";
						case "%W":
							return "\"+Scheduler.scheduler.date.to_fixed(Scheduler.scheduler.date.getISOWeek(date))+\"";
						default:
							return a;
					}
				});
				if( utc) format = format.replace(/date\.get/g, "date.getUTC" );
				return new Function("date", "return \"" + format + "\";" );
			},
			str_to_date : function( format, utc ){
				var splt = "var temp=date.match(/[a-zA-Z]+|[0-9]+/g);";
				var mask = format.match(/%[a-zA-Z]/g);
				for( var i = 0; i < mask.length; i++ ){
					switch( mask[ i ] ){
						case "%j":
						case "%d":
							splt += "set[ 2 ]=temp[" + i + "]||1;";
							break;
						case "%n":
						case "%m":
							splt += "set[ 1 ]=(temp[" + i + "]||1)-1;";
							break;
						case "%y":
							splt += "set[ 0 ]=temp[" + i + "]*1+(temp[" + i + "]>50?1900:2000);";
							break;
						case "%g":
						case "%G":
						case "%h":
						case "%H":
							splt += "set[ 3 ]=temp[" + i + "]||0;";
							break;
						case "%i":
							splt += "set[ 4 ]=temp[" + i + "]||0;";
							break;
						case "%Y":
							splt += "set[ 0 ]=temp[" + i + "]||0;";
							break;
						case "%a":
						case "%A":
							splt += "set[ 3 ]=set[ 3 ]%12+((temp[" + i + "]||'').toLowerCase()=='am'?0:12);";
							break;
						case "%s":
							splt += "set[5]=temp[" + i + "]||0;";
							break;
						case "%M":
							splt += "set[ 1 ]=Scheduler.scheduler.locale.date.month_short_hash[temp[" + i + "]]||0;";
							break;
						case "%F":
							splt += "set[ 1 ]=Scheduler.scheduler.locale.date.month_full_hash[temp[" + i + "]]||0;";
							break;
						default:
							break;
					}
				}
				var code = "set[ 0 ],set[ 1 ],set[ 2 ],set[ 3 ],set[ 4 ],set[5]";
				if( utc) code = " Date.UTC(" + code + ")";
				return new Function("date", "var set=[0,0,1,0,0,0]; " + splt + " return new Date(" + code + " );" );
			},
			getISOWeek : function( ndate ){
				if( !ndate) return false;
				var nday = ndate.getDay();
				if( nday === 0 ){
					nday = 7;
				}
				var first_thursday = new Date(ndate.valueOf() );
				first_thursday.setDate(ndate.getDate() + (4 - nday));
				var year_number = first_thursday.getFullYear();//year of the first Thursday
				var ordinal_date = Math.round((first_thursday.getTime() - new Date(year_number, 0, 1).getTime()) / 86400000);//ordinal date of the first Thursday - 1 (so not really ordinal date)
				var week_number = 1 + Math.floor(ordinal_date / 7);
				return week_number;
			},
			getUTCISOWeek : function( ndate ){
				return this.getISOWeek(this.convert_to_utc(ndate));
			},
			convert_to_utc : function( date ){
				return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds() );
			},
			day_week : function( sd, day, week ){
				sd.setDate(1);
				week = (week - 1) * 7;
				var cday = sd.getDay();
				var nday = day * 1 + week - cday + 1;
				sd.setDate(nday <= week ? (nday + 7) : nday);
			},
			add_list : function( date ){
				return this.add(date, 1, "year" );
			},
			list_start : function(){
				return this.date_part(scheduler._currentDate() );
			}
		};


		/*** configure templates ***/
		scheduler.templates = {};
		scheduler.init_templates = function(){
			var labels = scheduler.locale.labels;
			labels.sdr_save_btn = labels.icon_save;
			labels.sdr_cancel_btn = labels.icon_cancel;
			labels.sdr_delete_btn = labels.icon_delete;

			var d = scheduler.date.date_to_str;
			var s = scheduler.date.str_to_date;
			var c = scheduler.config;
			var f = function( a, b ){
				for( var c in b)
					if( !a[c]) a[c] = b[c];
			};
			f(scheduler.templates, {
				day_date : d(c.default_date),
				month_date : d(c.month_date),
				week_date : function( d1, d2 ){
					return scheduler.templates.day_date(d1) + " ~ " + scheduler.templates.day_date(scheduler.date.add(d2, -1, "day"));//&ndash;
				},
				day_scale_date : d(c.default_date),
				month_scale_date : d(c.week_date),
				week_scale_date : d(c.day_date),
				hour_scale : d(c.hour_date),
				time_picker : d(c.hour_date),
				event_date : d(c.hour_date),
				month_day : d(c.month_day),
				xml_date : s(c.xml_date, c.server_utc),
				load_format : d(c.load_date, c.server_utc),
				xml_format : d(c.xml_date, c.server_utc),
				api_date : s(c.api_date),
				event_header : function( start, end, ev ){
					return scheduler.templates.event_date( start ) + " ~ " + scheduler.templates.event_date( end );
				},
				event_text : function( start, end, ev ){
					return ev.text;
				},
				event_class : function( start, end, ev ){
					//event coloring
					var css = [];

					//options
					if( ev.type ){

						//출고-국외 event_release_oversea
						//출고-국내 event_release
						//출항-국외 event_departure_oversea
						//입고 event_wearing
						if( ev.oversea ){
							css.push("event_" + ev.type + "_oversea" );
						} else {
							css.push("event_" + ev.type);
						}

						//시행
						if( ev.completed ) css.push("event_completed" );
						else
						{
							//미입고,미출고 일때 event_incomplete;
							var delta = ev.end_date - scheduler._currentDate();
							if( delta < 1 ) css.push("event_incomplete" );
						}

						//scheduler.templates.event_bar_date 에서 기호로 처리
						//스케줄변경 일때 event_changed
						//if( ev.changed ){
						//	css.push("event_changed" );
						//}
					}

					if( ev.id === scheduler.getState().select_id ) css.push("selected" );

					/*
					 var mode = scheduler.getState().mode;
					 if( mode === "day" ){
					//custom logic here
					 }
					 else {
					//custom logic here
					 }
					 */
					return css.join(' ');
				},
				month_date_class : function( d )
				{
					//11.11 Single Day (광군절)
					if( d.getMonth() === 10 && d.getDate() === 11 ) return "special_day";
					else return "";
				},
				week_date_class : function( d ){ return ""; },
				event_bar_date : function( start, end, ev ){ return scheduler.templates.event_date( start ) + " "; },
				event_bar_text : function( start, end, ev ){ return ev.text; },
				month_events_link : function( date, count ){ return "<a>View more(" + count + " events)</a>"; },
				drag_marker_class : function( start, end, event ){ return ""; },
				drag_marker_content : function( start, end, event ){ return ""; }
			});
			this.callEvent( "onTemplatesReady", [] );
		};

		scheduler.uid = function()
		{
			if( !this._seed) this._seed = ( new Date() ).valueOf();
			return this._seed++;
		};

		scheduler._events = {};

		/**
		 * clear all events
		 */
		scheduler.clearAll = function()
		{
			this._events = {};
			this._loaded = {};

			this._edit_id = null;
			this._select_id = null;
			this._drag_id = null;
			this._drag_mode = null;
			this._drag_pos = null;

			this.clear_view();
			this.callEvent( "onClearAll", [] );
		};

		/**
		 * destroy scheduler
		 */
		scheduler.destroy = function()
		{
			this.clearAll();
			this.removeLightbox();
			this.detachAllEvents();

			//remove month tooltip
			this._removeMonthTooltip();

			//remove year tooltip
			this._removeYearTooltip();

			//remove window resize event
			this._detachDomEvent(window, "resize", scheduler._window_resize_event_handler);

			//remove scheduler elements
			var el = ( this._els ) ? this._els[ "sdr_cal_navline" ][ 0 ] : null;
			if( el ) el.parentElement.innerHTML = "";

			this._els = null;
			this._obj = null;
		};


		/*** scheduler event ***/
		scheduler.addEvent = function( start_date, end_date, text, id, extra_data ){

			if( !arguments.length)
				return this.addEventNow();

			var ev = start_date;
			if( arguments.length !== 1 ){
				ev = extra_data || {};
				ev.start_date = start_date;
				ev.end_date = end_date;
				ev.text = text;
				ev.id = id;
			}
			ev.id = ev.id || scheduler.uid();
			ev.text = ev.text || "";

			if( typeof ev.start_date === "string") ev.start_date = this.templates.api_date(ev.start_date);
			if( typeof ev.end_date === "string") ev.end_date = this.templates.api_date(ev.end_date);

			var d = (this.config.event_duration || this.config.time_step) * 60000;
			if( ev.start_date.valueOf() === ev.end_date.valueOf() ){
				ev.end_date.setTime(ev.end_date.valueOf() + d);
			}

			ev._timed = this.isOneDayEvent( ev );

			var is_new = !this._events[ev.id];
			this._events[ev.id] = ev;
			this.event_updated( ev );
			if( !this._loading ){
				this.callEvent( is_new ? "onEventAdded" : "onEventChanged", [ev.id, ev] );
			}

			if( ev.id ){
				ev = scheduler.getEvent(ev.id);
				if( this._is_modified_occurence( ev ) ){
					scheduler._add_rec_marker(ev, ev.event_length * 1000);
				}
				if( ev.rec_type ){
					ev.rec_pattern = ev.rec_type.split( "#" )[ 0 ];
				}
			}

			return ev.id;
		};

		scheduler.deleteEvent = function( id, silent ){
			var ev = this._events[ id ];
			if( !silent && (!this.callEvent( "onBeforeEventDelete", [id, ev]) || !this.callEvent( "onConfirmedBeforeEventDelete", [id, ev])))    return;
			if( ev ){
				this._select_id = null;
				delete this._events[ id ];
				this.event_updated( ev );
			}
			this.callEvent( "onEventDeleted", [id, ev] );
		};

		scheduler.getEvent = function( id ){
			return this._events[ id ];
		};

		scheduler.setEvent = function( id, hash ){
			if( !hash.id) hash.id = id;
			this._events[ id ] = hash;
		};

		scheduler.for_rendered = function( id, method ){
			for( var i = this._rendered.length - 1; i >= 0; i-- ){
				if( this._rendered[ i ].getAttribute("data-event-id") === id ){
					method(this._rendered[ i ], i);
				}
			}
		};

		scheduler.changeEventId = function( id, new_id ){
			if( id === new_id) return;
			var ev = this._events[ id ];
			if( ev ){
				ev.id = new_id;
				this._events[new_id] = ev;
				delete this._events[ id ];
			}
			this.for_rendered(id, function( r ){
				r.setAttribute("data-event-id", new_id);
			});
			if( this._select_id === id) this._select_id = new_id;
			if( this._edit_id === id) this._edit_id = new_id;
			//if( this._drag_id === id) this._drag_id = new_id;
			this.callEvent( "onEventIdChange", [id, new_id] );
		};

		(function(){
			var attrs = ["text", "Text", "start_date", "StartDate", "end_date", "EndDate"];
			var create_getter = function( name ){
				return function( id ){
					return (scheduler.getEvent( id ))[ name ];
				};
			};
			var create_setter = function( name ){
				return function( id, value ){
					var ev = scheduler.getEvent( id );
					ev[ name ] = value;
					ev._changed = true;
					ev._timed = this.isOneDayEvent( ev );
					scheduler.event_updated(ev, true);
				};
			};
			for( var i = 0; i < attrs.length; i += 2 ){
				scheduler["getEvent" + attrs[i + 1]] = create_getter(attrs[ i ] );
				scheduler["setEvent" + attrs[i + 1]] = create_setter(attrs[ i ] );
			}
		})();

		scheduler.event_updated = function( ev, force ){
			if( this.is_visible_events( ev ))
				this.render_view_data();
			else
				this.clear_event(ev.id);
		};

		scheduler.is_visible_events = function( ev ){
			//if in displayed dates
			var in_visible_range = (ev.start_date < this._max_date && this._min_date < ev.end_date);

			if( in_visible_range ){
				//end dates are not between last/first hours
				var end_dates_visible = (this._table_view || ((ev.end_date.getHours() >= this.config.first_hour && ev.end_date.getHours() < this.config.last_hour) ||
				(ev.start_date.getHours() >= this.config.first_hour && ev.start_date.getHours() < this.config.last_hour)));

				if( end_dates_visible ){
					return true;
				} else {
					//event is bigger than area hidden between last/first hours
					var event_duration = (ev.end_date.valueOf() - ev.start_date.valueOf()) / (1000 * 60 * 60),//hours
						hidden_duration = 24 - (this.config.last_hour - this.config.first_hour);

					return (event_duration > hidden_duration);
				}
			} else {
				return false;
			}
		};

		scheduler.isOneDayEvent = function( ev ){
			if( ev.rec_type) return true;

			var delta = ev.end_date.getDate() - ev.start_date.getDate();

			if( !delta)
				return ev.start_date.getMonth() === ev.end_date.getMonth() && ev.start_date.getFullYear() === ev.end_date.getFullYear();
			else {
				if( delta < 0) delta = Math.ceil((ev.end_date.valueOf() - ev.start_date.valueOf()) / (24 * 60 * 60 * 1000));
				return (delta === 1 && !ev.end_date.getHours() && !ev.end_date.getMinutes() && (ev.start_date.getHours() || ev.start_date.getMinutes() ));
			}
		};

		scheduler.get_visible_events = function( only_timed ){
			//not the best strategy for sure
			var stack = [];

			for( var id in this._events)
				if( this.is_visible_events(this._events[ id ]))
					if( !only_timed || this._events[ id ]._timed)
						if( this.filter_event(id, this._events[ id ]))
							stack.push(this._events[ id ] );

			return stack;
		};

		scheduler.filter_event = function( id, ev ){
			var filter = this["filter_" + this._mode];
			return (filter) ? filter(id, ev) : true;
		};

		scheduler._is_main_area_event = function( ev ){
			return !!ev._timed;
		};

		scheduler.render_view_data = function( evs, hold ){
			if( !evs ){
				if( this._not_render ){
					this._render_wait = true;
					return;
				}
				this._render_wait = false;

				this.clear_view();
				evs = this.get_visible_events(!(this._table_view || this.config.multi_day));
			}
			for( var i = 0, len = evs.length; i < len; i++ ){
				this._recalculate_timed(evs[ i ] );
			}

			if( this.config.multi_day && !this._table_view ){

				var tvs = [];
				var tvd = [];
				for( var i = 0; i < evs.length; i++ ){
					if( this._is_main_area_event(evs[ i ]))
						tvs.push(evs[ i ] );
					else
						tvd.push(evs[ i ] );
				}

				//multiday events
				this._rendered_location = this._els['sdr_multi_day'][ 0 ];
				this._table_view = true;
				this.render_data(tvd, hold);
				this._table_view = false;

				//normal events
				this._rendered_location = this._els['sdr_cal_data'][ 0 ];
				this._table_view = false;
				this.render_data(tvs, hold);

			} else {
				this._rendered_location = this._els['sdr_cal_data'][ 0 ];
				this.render_data(evs, hold);
			}
		};

		scheduler._view_month_day = function( e ){
			var date = scheduler.getActionData( e ).date;
			if( !scheduler.callEvent( "onViewMoreClick", [date]))
				return;
			scheduler.setCurrentView(date, "day" );
		};

		scheduler._render_month_link = function( ev ){
			var parent = this._rendered_location;
			var toRender = this._lame_clone( ev );

			//render links in each cell of multiday events
			for( var d = ev._sday; d < ev._eday; d++ ){

				toRender._sday = d;
				toRender._eday = d + 1;

				var date = scheduler.date;
				var curr = scheduler._min_date;
				curr = date.add(curr, toRender._sweek, "week" );
				curr = date.add(curr, toRender._sday, "day" );
				var count = scheduler.getEvents(curr, date.add(curr, 1, "day")).length;

				var pos = this._get_event_bar_pos(toRender);
				var w = (pos.x2 - pos.x);

				var el = document.createElement( "DIV" );
				el.onclick = function( e ){
					scheduler._view_month_day(e || event);
				};
				el.className = "sdr_month_link";
				el.style.top = pos.y + "px";
				el.style.left = pos.x + "px";
				el.style.width = w + "px";
				el.innerHTML = scheduler.templates.month_events_link(curr, count);
				this._rendered.push( el );

				parent.appendChild( el );
			}
		};

		scheduler._recalculate_timed = function( id ){
			if( !id) return;
			var ev;
			if( typeof( id ) !== "object" )
				ev = this._events[ id ];
			else
				ev = id;
			if( !ev) return;
			ev._timed = scheduler.isOneDayEvent( ev );
		};

		scheduler.attachEvent("onEventChanged", scheduler._recalculate_timed);
		scheduler.attachEvent("onEventAdded", scheduler._recalculate_timed);

		scheduler.render_data = function( evs, hold ){
			evs = this._pre_render_events(evs, hold);

			for( var i = 0; i < evs.length; i++ ){
				if( this._table_view ){
					if( scheduler._mode !== 'month' ){
						this.render_event_bar(evs[ i ] );//may be multiday section on other views
					} else {
						var max_evs = scheduler.config.max_month_events;
						if( max_evs !== max_evs * 1 || evs[ i ]._sorder < max_evs ){
							//of max number events per month cell is set and event can be rendered
							this.render_event_bar(evs[ i ] );
						} else if( max_evs !== undefined && evs[ i ]._sorder === max_evs ){
							//render 'view more' links
							scheduler._render_month_link(evs[ i ] );
						} else {
							//do not render events with ordinal number > maximum events per cell
						}
					}
				} else {
					this.render_event(evs[ i ] );
				}
			}
		};

		scheduler._get_first_visible_cell = function( cells ){
			for( var i = 0; i < cells.length; i++ ){
				if( (cells[ i ].className || "").indexOf("sdr_scale_ignore") === -1 ){
					return cells[ i ];
				}
			}
			//if no visible cell found, return cells[ 0 ] to be more tolerant, since it's the original logic
			return cells[ 0 ];
		};

		scheduler._pre_render_events = function( evs, hold ){
			var hb = this.xy.bar_height;
			var h_old = this._colsS.heights;
			var h = this._colsS.heights = [0, 0, 0, 0, 0, 0, 0];
			var data = this._els["sdr_cal_data"][ 0 ];

			if( !this._table_view)
				evs = this._pre_render_events_line(evs, hold);//ignore long events for now
			else
				evs = this._pre_render_events_table(evs, hold);

			if( this._table_view ){
				if( hold)
					this._colsS.heights = h_old;
				else {
					var evl = data.firstChild;
					if( evl.rows ){
						for( var i = 0; i < evl.rows.length; i++ ){
							h[ i ]++;
							var cells = evl.rows[ i ].cells;
							var cellHeight = this._colsS.height - this.xy.month_head_height;
							if( (h[ i ]) * hb > cellHeight ){//22 - height of cell's header
								//we have overflow, update heights

								var cHeight = cellHeight;
								if( this.config.max_month_events * 1 !== this.config.max_month_events || h[ i ] <= this.config.max_month_events ){
									cHeight = h[ i ] * hb;
								} else if( (this.config.max_month_events + 1) * hb > cellHeight ){
									cHeight = (this.config.max_month_events + 1) * hb;
								}

								for( var j = 0; j < cells.length; j++ ){
									cells[ j ].childNodes[ 1 ].style.height = cHeight + "px";
								}
								//	h[ i ] = (h[i - 1] || 0) + cells[ 0 ].offsetHeight;
							}

							h[ i ] = (h[i - 1] || 0) + scheduler._get_first_visible_cell(cells).offsetHeight;
						}
						h.unshift( 0 );
						if( evl.parentNode.offsetHeight < evl.parentNode.scrollHeight && !scheduler._colsS.scroll_fix && scheduler.xy.scroll_width ){

							var scale_settings = scheduler._colsS,
								sum_width = scale_settings[scale_settings.col_length],
								row_heights = scale_settings.heights.slice();

							sum_width -= (scheduler.xy.scroll_width || 0);
							this._calc_scale_sizes(sum_width, this._min_date, this._max_date);
							scheduler._colsS.heights = row_heights;

							this.set_xy( this._els["sdr_cal_header"][ 0 ], sum_width, this.xy.scale_height);
							scheduler._render_scales( this._els["sdr_cal_header"][ 0 ] );
							scheduler._render_month_scale( this._els["sdr_cal_data"][ 0 ], this._get_timeunit_start(), this._min_date);

							scale_settings.scroll_fix = true;
						}
					} else {
						if( !evs.length && this._els["sdr_multi_day"][ 0 ].style.visibility === "visible")
							h[ 0 ] = -1;
						if( evs.length || h[ 0 ] === -1 ){
							//shift days to have space for multiday events
							var childs = evl.parentNode.childNodes;

							//+1 so multiday events would have 2px from top and 2px from bottom by default
							var full_multi_day_height = (h[ 0 ] + 1) * hb + 1;

							var used_multi_day_height = full_multi_day_height;
							var used_multi_day_height_css = full_multi_day_height + "px";
							if( this.config.multi_day_height_limit ){
								used_multi_day_height = Math.min(full_multi_day_height, this.config.multi_day_height_limit);
								used_multi_day_height_css = used_multi_day_height + "px";
							}

							data.style.top = ( this._els[ "sdr_cal_navline" ][ 0 ].offsetHeight + this._els["sdr_cal_header"][ 0 ].offsetHeight + used_multi_day_height ) + 'px';
							data.style.height = (this._obj.offsetHeight - parseInt(data.style.top, 10) - (this.xy.margin_top || 0)) + 'px';

							var multi_day_section = this._els["sdr_multi_day"][ 0 ];
							multi_day_section.style.height = used_multi_day_height_css;
							multi_day_section.style.visibility = (h[ 0 ] === -1 ? "hidden" : "visible" );

							//icon
							var multi_day_icon = this._els["sdr_multi_day"][ 1 ];
							multi_day_icon.style.height = used_multi_day_height_css;
							multi_day_icon.style.visibility = (h[ 0 ] === -1 ? "hidden" : "visible" );
							multi_day_icon.className = h[ 0 ] ? "sdr_multi_day_icon" : "sdr_multi_day_icon_small";
							this._dy_shift = (h[ 0 ] + 1) * hb;
							if( this.config.multi_day_height_limit ){
								this._dy_shift = Math.min(this.config.multi_day_height_limit, this._dy_shift);
							}
							h[ 0 ] = 0;

							if( used_multi_day_height !== full_multi_day_height ){
								data.style.top = (parseInt(data.style.top) + 2) + "px";

								multi_day_section.style.overflowY = "auto";
								//	multi_day_section.style.width = (parseInt( this._els[ "sdr_cal_navline" ][ 0 ].style.width)) + "px";

								multi_day_icon.style.position = "fixed";
								multi_day_icon.style.top = "";
								multi_day_icon.style.left = "";
							}
						}
					}
				}
			}

			return evs;
		};
		scheduler._get_event_sday = function( ev ){
			return Math.floor((ev.start_date.valueOf() - this._min_date.valueOf()) / (24 * 60 * 60 * 1000));
		};
		scheduler._get_event_mapped_end_date = function( ev ){
			var end_date = ev.end_date;
			if( this.config.separate_short_events ){
				var ev_duration = (ev.end_date - ev.start_date) / 60000;//minutes
				if( ev_duration < this._min_mapped_duration ){
					end_date = this.date.add(end_date, this._min_mapped_duration - ev_duration, "minute" );
				}
			}
			return end_date;
		};
		scheduler._pre_render_events_line = function( evs, hold ){
			evs.sort(function( a, b ){
				if( a.start_date.valueOf() === b.start_date.valueOf())
					return a.id > b.id ? 1 : -1;
				return a.start_date > b.start_date ? 1 : -1;
			});
			var days = [];//events by weeks
			var evs_originals = [];

			this._min_mapped_duration = Math.ceil(this.xy.min_event_height * 60 / this.config.hour_size_px); //values could change along the way

			for( var i = 0; i < evs.length; i++ ){
				var ev = evs[ i ];

				//check date overflow
				var sd = ev.start_date;
				var ed = ev.end_date;
				//check scale overflow
				var sh = sd.getHours();
				var eh = ed.getHours();

				ev._sday = this._get_event_sday( ev );//sday based on event start_date
				if( this._ignores[ev._sday] ){
					//ignore event
					evs.splice(i, 1);
					i--;
					continue;
				}

				if( !days[ev._sday]) days[ev._sday] = [];

				if( !hold ){
					ev._inner = false;

					var stack = days[ev._sday];

					while( stack.length ){
						var t_ev = stack[stack.length - 1];
						var t_end_date = this._get_event_mapped_end_date(t_ev);
						if( t_end_date.valueOf() <= ev.start_date.valueOf() ){
							stack.splice(stack.length - 1, 1);
						} else {
							break;
						}
					}
					var slot_index = stack.length;
					var sorderSet = false;
					for( var j = 0; j < stack.length; j++ ){
						var t_ev = stack[ j ];
						var t_end_date = this._get_event_mapped_end_date(t_ev);
						if( t_end_date.valueOf() <= ev.start_date.valueOf() ){
							sorderSet = true;
							ev._sorder = t_ev._sorder;
							slot_index = j;
							ev._inner = true;
							break;
						}
					}

					if( stack.length ){
						stack[stack.length - 1]._inner = true;
					}

					if( !sorderSet ){
						if( stack.length ){
							if( stack.length <= stack[stack.length - 1]._sorder ){
								if( !stack[stack.length - 1]._sorder ){
									ev._sorder = 0;
								} else {
									for( j = 0; j < stack.length; j++ ){
										var _is_sorder = false;
										for( var k = 0; k < stack.length; k++ ){
											if( stack[ k ]._sorder === j ){
												_is_sorder = true;
												break;
											}
										}
										if( !_is_sorder ){
											ev._sorder = j;
											break;
										}
									}
								}
								ev._inner = true;
							} else {
								var _max_sorder = stack[ 0 ]._sorder;
								for( j = 1; j < stack.length; j++ ){
									if( stack[ j ]._sorder > _max_sorder ){
										_max_sorder = stack[ j ]._sorder;
									}
								}
								ev._sorder = _max_sorder + 1;
								ev._inner = false;
							}
						} else {
							ev._sorder = 0;
						}
					}

					stack.splice(slot_index, slot_index === stack.length ? 0 : 1, ev);

					if( stack.length > (stack.max_count || 0) ){
						stack.max_count = stack.length;
						ev._count = stack.length;
					} else {
						ev._count = (ev._count) ? ev._count : 1;
					}
				}

				if( sh < this.config.first_hour || eh >= this.config.last_hour ){
					//Need to create copy of event as we will be changing it's start/end date
					//e.g. first_hour = 11 and event.start_date hours = 9. Need to preserve that info
					evs_originals.push( ev );
					evs[ i ] = ev = this._copy_event( ev );

					if( sh < this.config.first_hour ){
						ev.start_date.setHours(this.config.first_hour);
						ev.start_date.setMinutes( 0 );
					}
					if( eh >= this.config.last_hour ){
						ev.end_date.setMinutes( 0 );
						ev.end_date.setHours(this.config.last_hour);
					}

					if( ev.start_date > ev.end_date || sh === this.config.last_hour ){
						evs.splice(i, 1);
						i--;
						continue;
					}
				}
			}
			if( !hold ){
				for( var i = 0; i < evs.length; i++ ){
					evs[ i ]._count = days[evs[ i ]._sday].max_count;
				}
				for( var i = 0; i < evs_originals.length; i++ ){
					evs_originals[ i ]._count = days[evs_originals[ i ]._sday].max_count;
				}
			}

			return evs;
		};

		scheduler._time_order = function( evs ){
			evs.sort(function( a, b ){
				if( a.start_date.valueOf() === b.start_date.valueOf() ){
					if( a._timed && !b._timed) return 1;
					if( !a._timed && b._timed) return -1;
					return a.id > b.id ? 1 : -1;
				}
				return a.start_date > b.start_date ? 1 : -1;
			});
		};

		scheduler._pre_render_events_table = function( evs, hold ){//max - max height of week slot
			this._time_order(evs);
			var out = [];
			var weeks = [
				[], [], [], [], [], [], []
			];//events by weeks
			//var max = this._colsS.heights;
			var max = scheduler._colsS.heights;
			var start_date;
			//var cols = this._cols.length;
			var cols = scheduler._cols.length;
			var chunks_info = {};

			for( var i = 0; i < evs.length; i++ ){
				var ev = evs[ i ];
				var id = ev.id;
				if( !chunks_info[ id ] ){
					chunks_info[ id ] = {
						first_chunk : true,
						last_chunk : true
					};
				}
				var chunk_info = chunks_info[ id ];
				var sd = (start_date || ev.start_date);
				var ed = ev.end_date;
				//trim events which are crossing through current view
				if( sd < this._min_date ){
					chunk_info.first_chunk = false;
					sd = this._min_date;
				}
				if( ed > this._max_date ){
					chunk_info.last_chunk = false;
					ed = this._max_date;
				}

				var locate_s = this.locate_holder_day(sd, false, ev);
				ev._sday = locate_s % cols;

				//skip single day events for ignored dates
				if( this._ignores[ev._sday] && ev._timed) continue;

				var locate_e = this.locate_holder_day(ed, true, ev) || cols;
				ev._eday = (locate_e % cols) || cols;//cols used to fill full week, when event end on monday
				ev._length = locate_e - locate_s;

				//3600000 - compensate 1 hour during winter|summer time shift
				ev._sweek = Math.floor((this._correct_shift(sd.valueOf(), 1) - this._min_date.valueOf()) / (60 * 60 * 1000 * 24 * cols));

				//current slot
				var stack = weeks[ev._sweek];
				//check order position
				var stack_line;

				for( stack_line = 0; stack_line < stack.length; stack_line++)
					if( stack[stack_line]._eday <= ev._sday)
						break;

				if( !ev._sorder || !hold ){
					ev._sorder = stack_line;
				}

				if( ev._sday + ev._length <= cols ){
					start_date = null;
					out.push( ev );
					stack[stack_line] = ev;
					//get max height of slot
					max[ev._sweek] = stack.length - 1;
					ev._first_chunk = chunk_info.first_chunk;
					ev._last_chunk = chunk_info.last_chunk;
				} else {//split long event in chunks
					var copy = this._copy_event( ev );
					copy.id = ev.id;
					copy._length = cols - ev._sday;
					copy._eday = cols;
					copy._sday = ev._sday;
					copy._sweek = ev._sweek;
					copy._sorder = ev._sorder;
					copy.end_date = this.date.add(sd, copy._length, "day" );
					copy._first_chunk = chunk_info.first_chunk;
					if( chunk_info.first_chunk ){
						chunk_info.first_chunk = false;
					}

					out.push( copy );
					stack[stack_line] = copy;
					start_date = copy.end_date;
					//get max height of slot
					max[ev._sweek] = stack.length - 1;
					i--;
					continue; //repeat same step
				}
			}
			return out;
		};

		scheduler._copy_dummy = function(){
			var a = new Date(this.start_date);
			var b = new Date(this.end_date);
			this.start_date = a;
			this.end_date = b;
			this.event_length = this.event_pid = this.rec_pattern = this.rec_type = null;
		};

		scheduler._copy_event = function( ev ){
			this._copy_dummy.prototype = ev;
			return new this._copy_dummy();
			//return {start_date:ev.start_date, end_date:ev.end_date, text:ev.text, id:ev.id}
		};

		scheduler._rendered = [];

		scheduler.clear_view = function(){
			for( var i = 0; i < this._rendered.length; i++ ){
				var obj = this._rendered[ i ];
				if( obj.parentNode) obj.parentNode.removeChild( obj );
			}
			this._rendered = [];
		};

		scheduler.updateEvent = function( id ){
			var ev = this.getEvent( id );

			if( ev && ev.rec_type ){
				//rec_type can be changed without the lightbox,
				//make sure rec_pattern updated as well
				ev.rec_pattern = (ev.rec_type || "").split( "#" )[ 0 ];
			}
			if( ev && ev.rec_type && !this._is_virtual_event( id ) ){
				scheduler.update_view();
			} else {
				this.clear_event( id );

				if( ev && this.is_visible_events( ev ) && this.filter_event(id, ev) && (this._table_view || this.config.multi_day || ev._timed) ){
					if( this.config.update_render ){
						this.render_view_data();
					} else {
						if( this.getState().mode === "month" && !this.getState().drag_id && !this.isOneDayEvent( ev ) ){
							this.render_view_data();
						} else {
							this.render_view_data([ev], true);
						}
					}
				}
			}
		};

		scheduler.clear_event = function( id ){
			this.for_rendered(id, function( node, i ){
				if( node.parentNode)
					node.parentNode.removeChild( node );
				scheduler._rendered.splice(i, 1);
			});
		};

		scheduler._y_from_date = function( date ){
			var sm = date.getHours() * 60 + date.getMinutes();
			return ((Math.round((sm * 60 * 1000 - this.config.first_hour * 60 * 60 * 1000) * this.config.hour_size_px / (60 * 60 * 1000))) % (this.config.hour_size_px * 24));//42px/hour
		};

		scheduler._calc_event_y = function( ev, min_height ){
			min_height = min_height || 0;
			var sm = ev.start_date.getHours() * 60 + ev.start_date.getMinutes();
			var em = (ev.end_date.getHours() * 60 + ev.end_date.getMinutes()) || (scheduler.config.last_hour * 60);
			var top = this._y_from_date(ev.start_date);

			var height = Math.max(min_height, (em - sm) * this.config.hour_size_px / 60);//42px/hour
			return {
				top : top,
				height : height
			};
		};

		scheduler.render_event = function( ev ){
			var menu = scheduler.xy.menu_width;
			var menu_offset = (this.config.use_select_menu_space) ? 0 : menu;
			if( ev._sday < 0) return;//can occur in case of recurring event during time shift

			var parent = scheduler.locate_holder(ev._sday);
			if( !parent) return;//attempt to render non-visible event

			var pos_y = this._calc_event_y(ev, scheduler.xy.min_event_height);
			var top = pos_y.top,
				height = pos_y.height;

			var ev_count = ev._count || 1;
			var ev_sorder = ev._sorder || 0;

			var width = Math.floor((parent.clientWidth - menu_offset) / ev_count);
			var left = ev_sorder * width + 1;
			if( !ev._inner) width = width * (ev_count - ev_sorder);
			if( this.config.cascade_event_display ){
				var limit = this.config.cascade_event_count;
				var margin = this.config.cascade_event_margin;
				left = ev_sorder % limit * margin;
				var right = (ev._inner) ? (ev_count - ev_sorder - 1) % limit * margin / 2 : 0;
				width = Math.floor(parent.clientWidth - menu_offset - left - right);
			}

			var d = this._render_v_bar(ev, menu_offset + left, top, width, height, ev._text_style, scheduler.templates.event_header(ev.start_date, ev.end_date, ev), scheduler.templates.event_text(ev.start_date, ev.end_date, ev));

			this._rendered.push( d );
			parent.appendChild( d );

			left = left + parseInt(parent.style.left, 10) + menu_offset;

			if( this._edit_id === ev.id ){

				d.style.zIndex = 1;//fix overlapping issue
				width = Math.max(width - 4, scheduler.xy.editor_width);
				d = document.createElement( "DIV" );
				d.setAttribute("data-event-id", ev.id);
				this.set_xy(d, width, height - 20, left, top + 14);
				d.className = "sdr_cal_event sdr_cal_editor";

				var tplClass = scheduler.templates.event_class(ev.start_date, ev.end_date, ev);

				if( tplClass ){
					d.className += " " + tplClass;
				}
				var d2 = document.createElement( "DIV" );
				this.set_xy(d2, width - 6, height - 26);
				d2.style.cssText += ";margin:2px 2px 2px 2px;overflow:hidden;";

				d.appendChild(d2);
				this._els["sdr_cal_data"][ 0 ].appendChild( d );
				this._rendered.push( d );

				d2.innerHTML = "<textarea class='sdr_cal_editor'>" + ev.text + "</textarea>";
				if( this._quirks7) d2.firstChild.style.height = height - 12 + "px";//IEFIX
				this._editor = d2.firstChild;
				this._editor.onkeydown = function( e ){
					if( (e || event).shiftKey) return true;
					var code = (e || event).keyCode;
					if( code === scheduler.keys.edit_save) scheduler.editStop( true );
					if( code === scheduler.keys.edit_cancel) scheduler.editStop( false );
				};
				this._editor.onselectstart = function( e ){
					(e || event).cancelBubble = true;
					return true;
				};
				scheduler._focus(d2.firstChild, true);
				//IE and opera can add x-scroll during focusing
				this._els["sdr_cal_data"][ 0 ].scrollLeft = 0;
			}
			if( this.xy.menu_width !== 0 && this._select_id === ev.id ){
				if( this.config.cascade_event_display && this._drag_mode)
					d.style.zIndex = 1;//fix overlapping issue for cascade view in case of dnd of selected event
				var icons = this.config["icons_" + ((this._edit_id === ev.id) ? "edit" : "select")];
				var icons_str = "";
				var bg_color = (ev.color ? ("background-color : " + ev.color + ";") : "" );
				var color = (ev.textColor ? ("color : " + ev.textColor + ";") : "" );
				for( var i = 0; i < icons.length; i++ )
					icons_str += "<div class='sdr_menu_icon " + icons[ i ] + "' style='" + bg_color + "" + color + "' title='" + this.locale.labels[icons[ i ]] + "'></div>";
				var obj = this._render_v_bar(ev, left - menu + 1, top, menu, icons.length * 20 + 26 - 2, "", "<div style='" + bg_color + "" + color + "' class='sdr_menu_head'></div>", icons_str, true);
				obj.style.left = left - menu + 1;
				this._els["sdr_cal_data"][ 0 ].appendChild( obj );
				this._rendered.push( obj );
			}
			if( this.config.drag_highlight && this._drag_id === ev.id ){
				this.highlightEventPosition( ev );
			}
		};

		scheduler._render_v_bar = function( ev, x, y, w, h, style, contentA, contentB, bottom ){
			var d = document.createElement( "DIV" );
			var id = ev.id;
			var cs = (bottom) ? "sdr_cal_event sdr_cal_select_menu" : "sdr_cal_event";

			var cse = scheduler.templates.event_class(ev.start_date, ev.end_date, ev);
			if( cse) cs = cs + " " + cse;

			var bg_color = (ev.color ? ("background:" + ev.color + ";") : "" );
			var color = (ev.textColor ? ("color:" + ev.textColor + ";") : "" );

			var html = '<div data-event-id="' + id + '" class="' + cs + '" style="position:absolute; top:' + y + 'px; left:' + x + 'px; width:' + (w - 4) + 'px; height:' + h + 'px;' + (style || "") + '"></div>';
			d.innerHTML = html;

			var container = d.cloneNode( true ).firstChild;

			if( !bottom && scheduler.renderEvent(container, ev, w, h, contentA, contentB) ){
				return container;
			} else {
				container = d.firstChild;

				var inner_html = '<div class="sdr_event_move sdr_header" style=" width:' + (w - 6) + 'px;' + bg_color + '" >&nbsp;</div>';
				inner_html += '<div class="sdr_event_move sdr_title" style="' + bg_color + '' + color + '">' + contentA + '</div>';
				inner_html += '<div class="sdr_body" style=" width:' + (w - (this._quirks ? 4 : 14)) + 'px; height:' + (h - (this._quirks ? 20 : 30) + 1) + 'px;' + bg_color + '' + color + '">' + contentB + '</div>';//+2 css specific, moved from render_event

				var footer_class = "sdr_event_resize sdr_footer";
				if( bottom)
					footer_class = "sdr_resize_denied " + footer_class;

				inner_html += '<div class="' + footer_class + '" style=" width:' + (w - 8) + 'px;' + (bottom ? ' margin-top:-1px;' : '') + '' + bg_color + '' + color + '" ></div>';

				container.innerHTML = inner_html;
			}

			return container;
		};

		scheduler.renderEvent = function(){
			return false;
		};

		scheduler.locate_holder = function( day ){
			if( this._mode === "day") return this._els["sdr_cal_data"][ 0 ].firstChild;//dirty
			return this._els["sdr_cal_data"][ 0 ].childNodes[ day ];
		};

		scheduler.locate_holder_day = function( date, past ){
			var day = Math.floor((this._correct_shift(date, 1) - this._min_date) / (60 * 60 * 24 * 1000));
			//when locating end data of event , we need to use next day if time part was defined
			if( past && this.date.time_part(date)) day++;
			return day;
		};

		scheduler._get_dnd_order = function( order, ev_height, max_height ){
			if( !this._drag_event)
				return order;
			if( !this._drag_event._orig_sorder)
				this._drag_event._orig_sorder = order;
			else
				order = this._drag_event._orig_sorder;

			var evTop = ev_height * order;
			while( (evTop + ev_height) > max_height ){
				order--;
				evTop -= ev_height;
			}
			order = Math.max(order, 0);
			return order;
		};

		scheduler._get_event_bar_pos = function( ev ){
			var x = this._colsS[ev._sday];
			var x2 = this._colsS[ev._eday];
			if( x2 === x) x2 = this._colsS[ev._eday + 1];
			var hb = this.xy.bar_height;

			var order = ev._sorder;
			if( ev.id === this._drag_id ){
				var cellHeight = this._colsS.heights[ev._sweek + 1] - this._colsS.heights[ev._sweek] - this.xy.month_head_height;//22 for month head height
				order = scheduler._get_dnd_order(order, hb, cellHeight);
			}
			var y_event_offset = order * hb;
			var y = this._colsS.heights[ev._sweek] + (this._colsS.height ? (this.xy.month_scale_height + 2) : 2 ) + y_event_offset;
			return {x : x, x2 : x2, y : y};
		};

		scheduler.render_event_bar = function( ev ){
			var parent = this._rendered_location;
			var pos = this._get_event_bar_pos( ev );

			var y = pos.y;
			var x = pos.x;
			var x2 = pos.x2;

			//resize for month mutliday events
			var resize_handle = "";

			//events in ignored dates
			if( !x2) return;

			var resizable = scheduler.config.resize_month_events && this._mode === "month" && (!ev._timed || scheduler.config.resize_month_timed);

			var d = document.createElement( "DIV" );
			var left_chunk = (ev.hasOwnProperty("_first_chunk") && ev._first_chunk),
				right_chunk = (ev.hasOwnProperty("_last_chunk") && ev._last_chunk);

			var resize_left = resizable && (ev._timed || left_chunk),
				resize_right = resizable && (ev._timed || right_chunk);

			var cs = "sdr_cal_event_clear";
			if( !ev._timed || resizable ){
				cs = "sdr_cal_event_line";
			}
			if( left_chunk ){
				cs += " sdr_cal_event_line_start";
			}
			if( right_chunk ){
				cs += " sdr_cal_event_line_end";
			}
			if( resize_left ){
				resize_handle += "<div class='sdr_event_resize sdr_event_resize_start'></div>";
			}
			if( resize_right ){
				resize_handle += "<div class='sdr_event_resize sdr_event_resize_end'></div>";
			}

			var cse = scheduler.templates.event_class(ev.start_date, ev.end_date, ev);
			if( cse ){
				cs += " " + cse;
			}

			var bg_color = (ev.color ? ("background:" + ev.color + ";") : "" );
			var color = (ev.textColor ? ("color:" + ev.textColor + ";") : "" );

			var style_text = [
				"position:absolute",
				"top:" + y + "px",
				"left:" + x + "px",
				"width:" + (x2 - x - 15) + "px",
				color,
				bg_color,
				(ev._text_style || "")
			].filter(String).join(";" );

			var html = '<div data-event-id="' + ev.id + '" class="' + cs + '" style="' + style_text + '">';
			if( resizable ){
				html += resize_handle;
			}
			if( scheduler.getState().mode === "month" ){
				ev = scheduler.getEvent(ev.id);//ev at this point could be a part (row in a month view) of a larger event
			}

			if( ev._timed || ev.oneday)
				html += scheduler.templates.event_bar_date(ev.start_date, ev.end_date, ev);
			html += scheduler.templates.event_bar_text(ev.start_date, ev.end_date, ev) + '</div>';
			html += '</div>';

			d.innerHTML = html;

			this._rendered.push(d.firstChild);
			parent.appendChild(d.firstChild);
		};

		scheduler._locate_event = function( node ){
			var id = null;
			while( node && !id && node.getAttribute ){
				id = node.getAttribute("data-event-id" );
				node = node.parentNode;
			}
			return id;
		};

		scheduler.edit = function( id ){
			if( this._edit_id === id) return;
			this.editStop(false, id);
			this._edit_id = id;
			this.updateEvent( id );
		};

		scheduler.editStop = function( mode, id ){
			if( id && this._edit_id === id) return;
			var ev = this.getEvent(this._edit_id);
			if( ev ){
				if( mode) ev.text = this._editor.value;
				this._edit_id = null;
				this._editor = null;
				this.updateEvent(ev.id);
				this._edit_stop_event(ev, mode);
			}
		};

		scheduler._edit_stop_event = function( ev, mode ){
			if( this._new_event ){
				if( !mode ){
					if( ev)//in case of custom lightbox user can already delete event
						this.deleteEvent(ev.id, true);
				} else {
					this.callEvent( "onEventAdded", [ev.id, ev] );
				}
				this._new_event = null;
			} else {
				if( mode ){
					this.callEvent( "onEventChanged", [ev.id, ev] );
				}
			}
		};

		scheduler.getEvents = function( from, to ){
			var result = [];
			for( var a in this._events ){
				var ev = this._events[ a ];
				if( ev && ( (!from && !to) || (ev.start_date < to && ev.end_date > from) ))
					result.push( ev );
			}
			return result;
		};
		scheduler.getRenderedEvent = function( id ){
			if( !id)
				return;
			var rendered_events = scheduler._rendered;
			for( var i = 0; i < rendered_events.length; i++ ){
				var rendered_event = rendered_events[ i ];
				if( rendered_event.getAttribute("data-event-id") === id ){
					return rendered_event;
				}
			}
			return null;
		};

		scheduler.showEvent = function( id, mode ){
			var ev = (typeof id === "number" || typeof id === "string") ? scheduler.getEvent( id ) : id;
			mode = mode || scheduler._mode;

			if( !ev || (this.checkEvent("onBeforeEventDisplay") && !this.callEvent( "onBeforeEventDisplay", [ev, mode])))
				return;

			var scroll_hour = scheduler.config.scroll_hour;
			scheduler.config.scroll_hour = ev.start_date.getHours();
			var preserve_scroll = scheduler.config.preserve_scroll;
			scheduler.config.preserve_scroll = false;

			var original_color = ev.color;
			var original_text_color = ev.textColor;
			if( scheduler.config.highlight_displayed_event ){
				ev.color = scheduler.config.displayed_event_color;
				ev.textColor = scheduler.config.displayed_event_text_color;
			}

			scheduler.setCurrentView(new Date(ev.start_date), mode);

			ev.color = original_color;
			ev.textColor = original_text_color;
			scheduler.config.scroll_hour = scroll_hour;
			scheduler.config.preserve_scroll = preserve_scroll;

			if( scheduler.matrix && scheduler.matrix[mode] ){
				scheduler._els.sdr_cal_data[ 0 ].scrollTop = getAbsoluteTop(scheduler.getRenderedEvent(ev.id)) - getAbsoluteTop(scheduler._els.sdr_cal_data[ 0 ]) - 20;
			}

			scheduler.callEvent( "onAfterEventDisplay", [ev, mode] );
		};

		scheduler._append_drag_marker = function( m ){
			if( m.parentNode) return;
			var zone = scheduler._els["sdr_cal_data"][ 0 ];

			var scale = zone.lastChild;
			if( scale.className && scale.className.indexOf("sdr_scale_holder") < 0 && scale.previousSibling ){
				scale = scale.previousSibling;
			}
			if( scale && scale.className.indexOf("sdr_scale_holder") === 0 ){
				scale.appendChild(m);
			}
		};

		scheduler._update_marker_position = function( m, event ){
			var size = scheduler._calc_event_y(event, 0);
			m.style.top = size.top + "px";
			m.style.height = size.height + "px";
		};

		scheduler.highlightEventPosition = function( event ){
			var m = document.createElement( "DIV" );

			m.setAttribute("data-event-id", event.id);
			this._rendered.push(m);
			this._update_marker_position(m, event);

			var css = this.templates.drag_marker_class(event.start_date, event.end_date, event);
			var html = this.templates.drag_marker_content(event.start_date, event.end_date, event);
			m.className = "sdr_drag_marker";
			if( css)
				m.className += " " + css;
			if( html)
				m.innerHTML = html;
			this._append_drag_marker(m);
		};

		scheduler._loaded = {};

		scheduler._load = function( url, from ){
			url = url || this._load_url;

			if( !url ){
				//if scheduler.setLoadMode is called before scheduler.init, initial rendering will invoke data loading while url is undefined
				return;
			}

			url += (url.indexOf("?") === -1 ? "?" : "&") + "timeshift=" + ( new Date() ).getTimezoneOffset();
			if( this.config.prevent_cache) url += "&uid=" + this.uid();
			var to;
			from = from || this._date;

			if( this._load_mode ){
				var lf = this.templates.load_format;

				from = this.date[this._load_mode + "_start"](new Date(from.valueOf()));
				while( from > this._min_date) from = this.date.add(from, -1, this._load_mode);
				to = from;

				var cache_line = true;
				while( to < this._max_date ){
					to = this.date.add(to, 1, this._load_mode);
					if( this._loaded[lf(from)] && cache_line ){
						from = this.date.add(from, 1, this._load_mode);
					} else {
						cache_line = false;
					}
				}

				var temp_to = to;
				do {
					to = temp_to;
					temp_to = this.date.add(to, -1, this._load_mode);
				} while( temp_to > from && this._loaded[lf(temp_to)] );

				if( to <= from ){
					return false;//already loaded
				}

				Scheduler.util.ajax.get(url + "&from=" + lf(from) + "&to=" + lf(to), function( data ){
					scheduler.on_load(data);
				});

				while( from < to ){
					this._loaded[lf(from)] = true;
					from = this.date.add(from, 1, this._load_mode);
				}
			} else {
				Scheduler.util.ajax.get(url, function( data ){
					scheduler.on_load(data);
				});
			}
			this.callEvent( "onDataLoaderStart", [] );
			return true;
		};

		scheduler.on_load = function( data ){
			var evs;
			var error = false;

			try {
				evs = this.json.parse(data.xmlDoc.responseText);
			} catch (e ){
				error = true;
			}

			if( error ){
				this.callEvent( "onLoadError", [data.xmlDoc] );
				evs = [];
			}

			scheduler._process_loading(evs);

			this.callEvent( "onDataLoaderEnd", [] );
		};

		scheduler._process_loading = function( evs ){
			this._loading = true;
			this._not_render = true;
			var ev;
			for( var i = 0; i < evs.length; i++ ){
				ev = evs[ i ];
				if( !this.callEvent( "onEventLoading", [evs[ i ]])) continue;

				//for schedule_logistics json data
				if( ev.date_start ){
					ev.start_date = ev.date_start.y + "/" + ev.date_start.m + "/" + ev.date_start.d + " " + ev.date_start.ho + ":" + ev.date_start.mi + ":" + ev.date_start.se;
					ev.end_date = ev.date_end.y + "/" + ev.date_end.m + "/" + ev.date_end.d + " " + ev.date_end.ho + ":" + ev.date_end.mi + ":" + ev.date_end.se;
					ev.changed = ev.date_changed;
					ev.oversea = ev.info.addr_place_of_delivery.cd$country !== "KR";
					//ev.completed = ev.completed;
					//ev.reference = ev.reference;
					//ev.info = ev.info;
					ev.text = "";
					var arr = [];
					if( ev.type === "release" ){
						arr.push(ev.info.nm$partner_buyer);
					}
					else if( ev.type === "departure" ){
						arr.push(ev.info.nm$partner_buyer);
					}
					else if( ev.type === "wearing" ){
						arr.push(ev.info.nm$partner_supplier);
					}
					arr.push(ev.info.nm$trade_terms);
					arr.push(ev.info.nm$category_delivery_type);
					arr.push(ev.info.addr_place_of_delivery.f);
					ev.text = arr.join(" / " );

					delete ev.date_start;
					delete ev.date_end;
					delete ev.date_changed;
				}

				this.addEvent( ev );
			}
			this._not_render = false;
			if( this._render_wait) this.render_view_data();

			this._loading = false;
			if( this._after_call) this._after_call();
			this._after_call = null;
		};

		scheduler._init_event = function( event ){
			event.text = (event.text || event._tagvalue) || "";
			event.start_date = scheduler._init_date(event.start_date);
			event.end_date = scheduler._init_date(event.end_date);
		};

		scheduler._init_date = function( date ){
			if( !date)
				return null;
			if( typeof date === "string")
				return scheduler.templates.xml_date(date);
			else
				return new Date(date);
		};

		/*** json ***/
		scheduler.json = {};
		scheduler.json.parse = function( data ){
			if( typeof data === "string" ){
				scheduler._temp = eval("(" + data + ")" );
				data = (scheduler._temp) ? scheduler._temp : [];
			}

			var evs = [];
			for( var i = 0; i < data.length; i++ ){
				var event = data[ i ];
				scheduler._init_event(event);
				evs.push(event);
			}
			return evs;
		};

		/*** load json data ***/
		scheduler.load = function( url, callback ){
			if( typeof url === "string" ){
				//string url
				this._load_url = url;
				this._after_call = callback;
				this._load(url, this._date);
			} else {
				//array json
				var data = {xmlDoc : {responseText : url}};
				this._after_call = callback;
				this.on_load(data);
			}
		};

		//possible values - day,week,month,year,list,all
		scheduler.setLoadMode = function( mode ){
			if( mode === "all") mode = "";
			this._load_mode = mode;
		};

		scheduler._xmlNodeToJSON = function( node ){
			var t = {};
			for( var i = 0; i < node.attributes.length; i++ )
				t[node.attributes[ i ].name] = node.attributes[ i ].value;

			for( var i = 0; i < node.childNodes.length; i++ ){
				var child = node.childNodes[ i ];
				if( child.nodeType === 1)
					t[child.tagName] = child.firstChild ? child.firstChild.nodeValue : "";
			}

			if( !t.text) t.text = node.firstChild ? node.firstChild.nodeValue : "";

			return t;
		};

		scheduler.attachEvent("onDataLoaderStart", function(){
			if( this.config.show_loading === true ){
				var t;
				t = this.config.show_loading = document.createElement( "DIV" );
				t.className = 'sdr_loading';
				t.style.left = Math.round((this._x - 128) / 2) + "px";
				t.style.top = Math.round((this._y - 15) / 2) + "px";
				this._obj.appendChild( t );
			}
		});

		scheduler.attachEvent("onDataLoaderEnd", function(){
			var t = this.config.show_loading;
			if( t && typeof t === "object" ){
				this._obj.removeChild( t );
				this.config.show_loading = true;
			}
		});

		/*** lightbox ***/
		scheduler._lightbox_controls = {};

		scheduler.formSection = function( name ){
			var config = this.config.lightbox.sections;
			var i = 0;
			for( i; i < config.length; i++ )
				if( config[ i ].name === name)
					break;
			var section = config[ i ];
			if( !scheduler._lightbox)
				scheduler.getLightbox();
			var header = document.getElementById(section.id);
			var node = header.nextSibling;

			var result = {
				section : section,
				header : header,
				node : node,
				getValue : function( ev ){
					return scheduler.form_blocks[section.type].get_value(node, (ev || {}), section);
				},
				setValue : function( value, ev ){
					return scheduler.form_blocks[section.type].set_value(node, value, (ev || {}), section);
				}
			};

			var handler = scheduler._lightbox_controls["get_" + section.type + "_control"];
			return handler ? handler( result ) : result;
		};

		scheduler._lightbox_controls.get_template_control = function( result ){
			result.control = result.node;
			return result;
		};

		scheduler._lightbox_controls.get_select_control = function( result ){
			result.control = result.node.getElementsByTagName('select')[ 0 ];
			return result;
		};

		scheduler._lightbox_controls.get_textarea_control = function( result ){
			result.control = result.node.getElementsByTagName('textarea')[ 0 ];
			return result;
		};

		scheduler._lightbox_controls.get_time_control = function( result ){
			result.control = result.node.getElementsByTagName('select');//array
			return result;
		};

		scheduler.form_blocks = {
			template : {
				render : function( sns ){
					var height = (sns.height || "30") + "px";
					return "<div class='sdr_cal_ltext sdr_cal_template' style='height:" + height + ";'></div>";
				},
				set_value : function( node, value, ev, config ){
					node.innerHTML = value || "";
				},
				get_value : function( node, ev, config ){
					return node.innerHTML || "";
				},
				focus : function( node ){
				}
			},
			textarea : {
				render : function( sns ){
					var height = (sns.height || "130") + "px";
					return "<div class='sdr_cal_ltext' style='height:" + height + ";'><textarea></textarea></div>";
				},
				set_value : function( node, value, ev ){
					node.firstChild.value = value || "";
				},
				get_value : function( node, ev ){
					return node.firstChild.value;
				},
				focus : function( node ){
					var a = node.firstChild;
					scheduler._focus(a, true);
				}
			},
			select : {
				render : function( sns ){
					var height = (sns.height || "23") + "px";
					var html = "<div class='sdr_cal_ltext' style='height:" + height + ";'><select style='width:100%;'>";
					for( var i = 0; i < sns.options.length; i++ )
						html += "<option value='" + sns.options[ i ].key + "'>" + sns.options[ i ].label + "</option>";
					html += "</select></div>";
					return html;
				},
				set_value : function( node, value, ev, sns ){
					var select = node.firstChild;
					if( !select._sdr_onchange && sns.onchange ){
						select.onchange = sns.onchange;
						select._sdr_onchange = true;
					}
					if( typeof value === "undefined")
						value = (select.options[ 0 ] || {}).value;
					select.value = value || "";
				},
				get_value : function( node, ev ){
					return node.firstChild.value;
				},
				focus : function( node ){
					var a = node.firstChild;
					scheduler._focus(a, true);
				}
			},
			time : {
				render : function( sns ){
					if( !sns.time_format ){
						//default order
						sns.time_format = ["%Y", "%m", "%d", "%H:%i"];
					}
					//map : default order => real one
					sns._time_format_order = {};
					var time_format = sns.time_format;

					var cfg = scheduler.config;
					var dt = this.date.date_part(scheduler._currentDate() );
					var last = 24 * 60, first = 0;
					if( scheduler.config.limit_time_select ){
						last = 60 * cfg.last_hour + 1;
						first = 60 * cfg.first_hour;
						dt.setHours(cfg.first_hour);
					}
					var html = "";

					for( var p = 0; p < time_format.length; p++ ){
						var time_option = time_format[p];

						//adding spaces between selects
						if( p > 0 ){
							html += " ";
						}

						switch( time_option ){
							case "%Y":
								sns._time_format_order[ 3 ] = p;
								//year
								html += "<select>";
								var year = dt.getFullYear() - 5;//maybe take from config?
								for( var i = 0; i < 10; i++ )
									html += "<option value='" + (year + i) + "'>" + (year + i) + "</option>";
								html += "</select> ";
								break;
							case "%m":
								sns._time_format_order[ 2 ] = p;
								//month
								html += "<select>";
								for( var i = 0; i < 12; i++ )
									html += "<option value='" + i + "'>" + this.locale.date.month_full[ i ] + "</option>";
								html += "</select>";
								break;
							case "%d":
								sns._time_format_order[ 1 ] = p;
								//days
								html += "<select>";
								for( var i = 1; i < 32; i++ )
									html += "<option value='" + i + "'>" + i + "</option>";
								html += "</select>";
								break;
							case "%H:%i":
								sns._time_format_order[ 0 ] = p;
								//hours
								html += "<select>";
								var i = first;
								var tdate = dt.getDate();
								sns._time_values = [];

								while( i < last ){
									var time = this.templates.time_picker(dt);
									html += "<option value='" + i + "'>" + time + "</option>";
									sns._time_values.push( i );
									dt.setTime(dt.valueOf() + this.config.time_step * 60 * 1000);
									var diff = (dt.getDate() !== tdate) ? 1 : 0;//moved or not to the next day
									i = diff * 24 * 60 + dt.getHours() * 60 + dt.getMinutes();
								}
								html += "</select>";
								break;
						}
					}

					return "<div style='height:30px;padding-top:0px;font-size:inherit;' class='sdr_section_time'>" + html + "<span style='font-weight:normal; font-size:10pt;'> ~ </span>" + html + "</div>";
				},
				set_value : function( node, value, ev, config ){
					var cfg = scheduler.config;
					var s = node.getElementsByTagName("select" );
					var map = config._time_format_order;
					var start_date, end_date;

					if( cfg.full_day ){
						if( !node._full_day ){
							var html = "<label class='sdr_fullday'><input type='checkbox' name='full_day' value='true'> " + scheduler.locale.labels.full_day + "</label></input>";
							if( !scheduler.config.wide_form)
								html = node.previousSibling.innerHTML + html;
							node.previousSibling.innerHTML = html;
							node._full_day = true;
						}
						var input = node.previousSibling.getElementsByTagName("input")[ 0 ];
						input.checked = (scheduler.date.time_part(ev.start_date) === 0 && scheduler.date.time_part(ev.end_date) === 0);

						s[map[ 0 ]].disabled = input.checked;
						s[map[ 0 ] + s.length / 2].disabled = input.checked;

						input.onclick = function(){
							if( input.checked ){
								var obj = {};
								scheduler.form_blocks.time.get_value(node, obj, config);

								start_date = scheduler.date.date_part(obj.start_date);
								end_date = scheduler.date.date_part(obj.end_date);

								if( +end_date === +start_date || (+end_date >= +start_date && (ev.end_date.getHours() !== 0 || ev.end_date.getMinutes() !== 0)))
									end_date = scheduler.date.add(end_date, 1, "day" );
							} else {
								start_date = null;
								end_date = null;
							}

							s[map[ 0 ]].disabled = input.checked;
							s[map[ 0 ] + s.length / 2].disabled = input.checked;

							_fill_lightbox_select(s, 0, start_date || ev.start_date);
							_fill_lightbox_select(s, 4, end_date || ev.end_date);
						};
					}

					if( cfg.auto_end_date && cfg.event_duration ){
						var _update_lightbox_select = function(){
							start_date = new Date(s[map[ 3 ]].value, s[map[ 2 ]].value, s[map[ 1 ]].value, 0, s[map[ 0 ]].value);
							end_date = new Date(start_date.getTime() + (scheduler.config.event_duration * 60 * 1000));
							_fill_lightbox_select(s, 4, end_date);
						};
						for( var i = 0; i < 4; i++ ){
							s[ i ].onchange = _update_lightbox_select;
						}
					}

					function _fill_lightbox_select(s, i, d ){
						var time_values = config._time_values;
						var direct_value = d.getHours() * 60 + d.getMinutes();
						var fixed_value = direct_value;
						var value_found = false;
						for( var k = 0; k < time_values.length; k++ ){
							var t_v = time_values[ k ];
							if( t_v === direct_value ){
								value_found = true;
								break;
							}
							if( t_v < direct_value ){
								fixed_value = t_v;
							}
						}

						s[i + map[ 0 ]].value = (value_found) ? direct_value : fixed_value;
						if( !(value_found || fixed_value) ){
							s[i + map[ 0 ]].selectedIndex = -1;//show empty select in FF
						}
						s[i + map[ 1 ]].value = d.getDate();
						s[i + map[ 2 ]].value = d.getMonth();
						s[i + map[ 3 ]].value = d.getFullYear();
					}

					_fill_lightbox_select(s, 0, ev.start_date);
					_fill_lightbox_select(s, 4, ev.end_date);
				},
				get_value : function( node, ev, config ){
					var s = node.getElementsByTagName("select" );
					var map = config._time_format_order;

					ev.start_date = new Date(s[map[ 3 ]].value, s[map[ 2 ]].value, s[map[ 1 ]].value, 0, s[map[ 0 ]].value);
					ev.end_date = new Date(s[map[ 3 ] + 4].value, s[map[ 2 ] + 4].value, s[map[ 1 ] + 4].value, 0, s[map[ 0 ] + 4].value);

					if( !(s[map[ 3 ]].value && s[map[ 3 ] + 4].value) ){
						//use the previous date if start/end years are empty (outside lightbox range)
						var original = this.getEvent(this._lightbox_id);
						if( original ){
							ev.start_date = original.start_date;
							ev.end_date = original.end_date;
						}
					}

					if( ev.end_date <= ev.start_date ){
						ev.end_date = scheduler.date.add(ev.start_date, scheduler.config.time_step, "minute" );
					}

					return {
						start_date : new Date(ev.start_date),
						end_date : new Date(ev.end_date)
					};
				},
				focus : function( node ){
					scheduler._focus(node.getElementsByTagName("select")[ 0 ] );
				}
			}
		};

		scheduler.showCover = function( box ){
			if( box ){
				box.style.display = "block";

				var scroll_top = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;
				var scroll_left = window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft;

				var view_height = window.innerHeight || document.documentElement.clientHeight;

				if( scroll_top)//if vertical scroll on window
					box.style.top = Math.round(scroll_top + Math.max((view_height - box.offsetHeight) / 2, 0)) + "px";
				else//vertical scroll on body
					box.style.top = Math.round(Math.max(((view_height - box.offsetHeight) / 2), 0) + 9) + "px";//+9 for compatibility with auto tests

				//not quite accurate but used for compatibility reasons
				if( document.documentElement.scrollWidth > document.body.offsetWidth)//if horizontal scroll on the window
					box.style.left = Math.round(scroll_left + (document.body.offsetWidth - box.offsetWidth) / 2) + "px";
				else//horizontal scroll on the body
					box.style.left = Math.round((document.body.offsetWidth - box.offsetWidth) / 2) + "px";
			}
			this.show_cover();
		};

		scheduler.showLightbox = function( id ){
			if( !id) return;
			if( !this.callEvent( "onBeforeLightbox", [ id ]) ){
				if( this._new_event)
					this._new_event = null;
				return;
			}
			var box = this.getLightbox();
			this.showCover( box );
			this._fill_lightbox(id, box);
			this.callEvent( "onLightbox", [ id ] );
		};

		scheduler._fill_lightbox = function( id, box ){
			var ev = this.getEvent( id );
			var s = box.getElementsByTagName("span" );
			if( scheduler.templates.lightbox_header ){
				s[ 1 ].innerHTML = "";
				s[ 2 ].innerHTML = scheduler.templates.lightbox_header(ev.start_date, ev.end_date, ev);
			} else {
				s[ 1 ].innerHTML = this.templates.event_header(ev.start_date, ev.end_date, ev);
				s[ 2 ].innerHTML = (this.templates.event_bar_text(ev.start_date, ev.end_date, ev) || "").substr(0, 70);//IE6 fix
			}

			var sns = this.config.lightbox.sections;
			for( var i = 0; i < sns.length; i++ ){
				var current_sns = sns[ i ];
				var node = document.getElementById(current_sns.id).nextSibling;
				var block = this.form_blocks[current_sns.type];
				var value = (ev[current_sns.map_to] !== undefined) ? ev[current_sns.map_to] : current_sns.default_value;
				block.set_value.call(this, node, value, ev, current_sns);
				if( sns[ i ].focus)
					block.focus.call(this, node);
			}

			scheduler._lightbox_id = id;
		};

		scheduler._lightbox_out = function( ev ){
			var sns = this.config.lightbox.sections;
			for( var i = 0; i < sns.length; i++ ){
				var node = document.getElementById(sns[ i ].id);
				node = (node ? node.nextSibling : node);
				var block = this.form_blocks[sns[ i ].type];
				var res = block.get_value.call(this, node, ev, sns[ i ] );
				if( sns[ i ].map_to !== "auto")
					ev[sns[ i ].map_to] = res;
			}
			return ev;
		};

		scheduler._empty_lightbox = function( data ){
			var id = scheduler._lightbox_id;
			var ev = this.getEvent( id );
			var box = this.getLightbox();

			this._lame_copy(ev, data);

			this.setEvent(ev.id, ev);
			this._edit_stop_event(ev, true);
			this.render_view_data();
		};

		scheduler.hide_lightbox = function( id )
		{
			this.hideCover(this.getLightbox() );
			this._lightbox_id = null;
			this.callEvent( "onAfterLightbox", [] );
		};

		scheduler.hideCover = function( box )
		{
			if( box ) box.style.display = "none";
			this.hide_cover();
		};

		scheduler.hide_cover = function()
		{
			if( this._cover) this._cover.parentNode.removeChild(this._cover);
			this._cover = null;
		};

		scheduler.show_cover = function()
		{
			if( this._cover) return;

			this._cover = document.createElement( "DIV" );
			this._cover.className = "sdr_cal_cover";
			var _document_height = ((document.height !== undefined) ? document.height : document.body.offsetHeight);
			var _scroll_height = ((document.documentElement) ? document.documentElement.scrollHeight : 0);
			this._cover.style.height = Math.max(_document_height, _scroll_height) + 'px';
			document.body.appendChild(this._cover);
		};

		scheduler.save_lightbox = function(){
			var data = this._lightbox_out({}, this._lame_copy(this.getEvent(this._lightbox_id)));
			if( this.checkEvent("onEventSave") && !this.callEvent( "onEventSave", [this._lightbox_id, data, this._new_event]))
				return;
			this._empty_lightbox(data);
			this.hide_lightbox();
		};

		scheduler.startLightbox = function( id, box )
		{
			this._lightbox_id = id;
			this._custom_lightbox = true;

			this._temp_lightbox = this._lightbox;
			this._lightbox = box;
			this.showCover( box );
		};

		scheduler.endLightbox = function( mode, box )
		{
			this._edit_stop_event(scheduler.getEvent(this._lightbox_id), mode);
			if( mode ) scheduler.render_view_data();

			this.hideCover( box );

			if( this._custom_lightbox )
			{
				this._lightbox = this._temp_lightbox;
				this._custom_lightbox = false;
			}
			this._temp_lightbox = this._lightbox_id = null;//in case of custom lightbox user only calls endLightbox so we need to reset _lightbox_id
		};

		scheduler.removeLightbox = function()
		{
			if( scheduler._lightbox && !scheduler._custom_lightbox ) scheduler._lightbox.parentNode.removeChild(scheduler._lightbox);
			scheduler._lightbox = null;
		};

		scheduler.cancel_lightbox = function()
		{
			this.callEvent( "onEventCancel", [this._lightbox_id, this._new_event] );
			this.endLightbox( false );
			this.hide_lightbox();
		};

		scheduler._init_lightbox_events = function()
		{
			this.getLightbox().onclick = function( e )
			{
				var src = e ? e.target : event.srcElement;
				if( !src.className) src = src.previousSibling;
				if( src && src.className )
				{
					switch( src.className )
					{
						case "sdr_save_btn" : scheduler.save_lightbox(); break;
						case "sdr_delete_btn" :
							var c = scheduler.locale.labels.confirm_deleting;

							scheduler._component_confirm(c, scheduler.locale.labels.title_confirm_deleting, function(){
								scheduler.deleteEvent(scheduler._lightbox_id);
								scheduler._new_event = null;//clear flag, if it was unsaved event;
								scheduler.hide_lightbox();
							});

							break;
						case "sdr_cancel_btn":
							scheduler.cancel_lightbox();
							break;

						default:
							if( src.getAttribute("data-sdr-button") ){
								scheduler.callEvent( "onLightboxButton", [src.className, src, e] );
							} else {
								var index, block, sec;
								if( src.className.indexOf("sdr_custom_button") !== -1 ){
									if( src.className.indexOf("sdr_custom_button_") !== -1 ){
										index = src.parentNode.getAttribute("data-index" );
										sec = src.parentNode.parentNode;
									} else {
										index = src.getAttribute("data-index" );
										sec = src.parentNode;
										src = src.firstChild;
									}
								}
								if( index ){
									block = scheduler.form_blocks[scheduler.config.lightbox.sections[index].type];
									block.button_click(index, src, sec, sec.nextSibling);
								}
							}
							break;
					}
				}
			};
			this.getLightbox().onkeydown = function( e ){
				switch( (e || event).keyCode ){
					case scheduler.keys.edit_save:
						if( (e || event).shiftKey) return;
						scheduler.save_lightbox();
						break;
					case scheduler.keys.edit_cancel:
						scheduler.cancel_lightbox();
						break;
					default:
						break;
				}
			};
		};

		scheduler.setLightboxSize = function(){
			var d = this._lightbox;
			if( !d) return;

			var con = d.childNodes[ 1 ];
			con.style.height = "0px";
			con.style.height = con.scrollHeight + "px";
			d.style.height = con.scrollHeight + scheduler.xy.lightbox_additional_height + "px";
			con.style.height = con.scrollHeight + "px";//it is incredible , how ugly IE can be
		};

		scheduler._init_dnd_events = function(){
			Scheduler.eventObject._attachDomEvent(document.body, "mousemove", scheduler._move_while_dnd);
			Scheduler.eventObject._attachDomEvent(document.body, "mouseup", scheduler._finish_dnd);
			//self reset function
			scheduler._init_dnd_events = function(){
			};
		};
		scheduler._move_while_dnd = function( e ){
			if( scheduler._dnd_start_lb ){
				if( !scheduler.sdr_unselectable ){
					document.body.className += " sdr_unselectable";
					scheduler.sdr_unselectable = true;
				}
				var lb = scheduler.getLightbox();
				var now = (e && e.target) ? [e.pageX, e.pageY] : [event.clientX, event.clientY];
				lb.style.top = scheduler._lb_start[ 1 ] + now[ 1 ] - scheduler._dnd_start_lb[ 1 ] + "px";
				lb.style.left = scheduler._lb_start[ 0 ] + now[ 0 ] - scheduler._dnd_start_lb[ 0 ] + "px";
			}
		};
		scheduler._ready_to_dnd = function( e ){
			var lb = scheduler.getLightbox();
			scheduler._lb_start = [parseInt(lb.style.left, 10), parseInt(lb.style.top, 10)];
			scheduler._dnd_start_lb = (e && e.target) ? [e.pageX, e.pageY] : [event.clientX, event.clientY];
		};
		scheduler._finish_dnd = function(){
			if( scheduler._lb_start ){
				scheduler._lb_start = scheduler._dnd_start_lb = false;
				document.body.className = document.body.className.replace(" sdr_unselectable", "" );
				if( !document.body.className) document.body.removeAttribute("class" );
				scheduler.sdr_unselectable = false;
			}
		};

		scheduler.getLightbox = function(){//scheduler.config.wide_form=true;
			if( !this._lightbox ){
				var d = document.createElement( "DIV" );
				d.className = "sdr_cal_light";

				if( scheduler.config.wide_form)
					d.className += " sdr_cal_light_wide";
				if( scheduler.form_blocks.recurring)
					d.className += " sdr_cal_light_rec";
				if( /msie|MSIE 6/.test(navigator.userAgent))
					d.className += " sdr_ie6";

				d.style.visibility = "hidden";

				var html = this._lightbox_template;

				var buttons = this.config.buttons_left;
				for( var i = 0; i < buttons.length; i++ ){
					html += "<div class='sdr_btn_set sdr_left_btn_set " + buttons[ i ] + "_set'><div data-sdr-button='1' class='" + buttons[ i ] + "'></div><div>" + scheduler.locale.labels[buttons[ i ]] + "</div></div>";
				}

				buttons = this.config.buttons_right;
				for( var i = 0; i < buttons.length; i++ ){
					html += "<div class='sdr_btn_set sdr_right_btn_set " + buttons[ i ] + "_set' style='float:right;'><div data-sdr-button='1' class='" + buttons[ i ] + "'></div><div>" + scheduler.locale.labels[buttons[ i ]] + "</div></div>";
				}

				html += "</div>";
				d.innerHTML = html;
				if( scheduler.config.drag_lightbox ){
					d.firstChild.onmousedown = scheduler._ready_to_dnd;
					d.firstChild.onselectstart = function(){
						return false;
					};
					d.firstChild.style.cursor = "pointer";
					scheduler._init_dnd_events();

				}
				document.body.insertBefore(d, document.body.firstChild);
				this._lightbox = d;

				var sns = this.config.lightbox.sections;
				html = "";
				for( var i = 0; i < sns.length; i++ ){
					var block = this.form_blocks[sns[ i ].type];
					if( !block) continue;//ignore incorrect blocks
					sns[ i ].id = "area_" + this.uid();
					var button = "";
					if( sns[ i ].button ){
						button = "<div class='sdr_custom_button' data-index='" + i + "'><div class='sdr_custom_button_" + sns[ i ].button + "'></div><div>" + this.locale.labels["button_" + sns[ i ].button] + "</div></div>";
					}

					if( this.config.wide_form ){
						html += "<div class='sdr_wrap_section'>";
					}

					var label_name = this.locale.labels["section_" + sns[ i ].name];
					if( typeof label_name !== "string" ){
						label_name = sns[ i ].name;
					}
					html += "<div id='" + sns[ i ].id + "' class='sdr_cal_lsection'>" + button + label_name + "</div>" + block.render.call(this, sns[ i ] );
					html += "</div>";
				}

				var ds = d.getElementsByTagName("div" );
				for( var i = 0; i < ds.length; i++ ){
					var t_ds = ds[ i ];
					if( t_ds.className === "sdr_cal_larea" ){
						t_ds.innerHTML = html;
						break;
					}
				}

				//sizes
				this.setLightboxSize();

				this._init_lightbox_events( this );
				d.style.display = "none";
				d.style.visibility = "visible";
			}
			return this._lightbox;
		};

		scheduler.attachEvent("onEventIdChange", function( old_id, new_id ){
			if( this._lightbox_id === old_id)
				this._lightbox_id = new_id;
		});

		scheduler._lightbox_template = "<div class='sdr_cal_ltitle'><span class='sdr_mark'>&nbsp;</span><span class='sdr_time'></span><span class='sdr_title'></span></div><div class='sdr_cal_larea'></div>";

		//for mobile & touch devices
		scheduler._init_touch_events = function(){
			if( this.config.touch !== "force")
				this.config.touch = this.config.touch &&
					((navigator.userAgent.indexOf("Mobile") !== -1) ||
					(navigator.userAgent.indexOf("iPad") !== -1) ||
					(navigator.userAgent.indexOf("Android") !== -1) ||
					(navigator.userAgent.indexOf("Touch") !== -1));

			if( this.config.touch ){
				this.xy.scroll_width = 0;
				if( window.navigator.msPointerEnabled ){
					this._touch_events(["MSPointerMove", "MSPointerDown", "MSPointerUp"], function( ev ){
						if( ev.pointerType === ev.MSPOINTER_TYPE_MOUSE) return null;
						return ev;
					}, function( ev ){
						return (!ev || ev.pointerType === ev.MSPOINTER_TYPE_MOUSE);
					});
					this._obj.ondblclick = function(){
					};
				} else
					this._touch_events(["touchmove", "touchstart", "touchend"], function( ev ){
						if( ev.touches && ev.touches.length > 1) return null;
						if( ev.touches[ 0 ])
							return {target : ev.target, pageX : ev.touches[ 0 ].pageX, pageY : ev.touches[ 0 ].pageY};
						else
							return ev;
					}, function(){
						return false;
					});
			}
		};
		//for mobile & touch devices
		scheduler._touch_events = function( names, accessor, ignore ){
			//webkit on android need to be handled separately
			//var a_webkit = (navigator.userAgent.indexOf("Android") !== -1) && (navigator.userAgent.indexOf("WebKit") !== -1);
			var source, tracker, timer, drag_mode, scroll_mode, action_mode;
			var dblclicktime = 0;

			function attachTouchEvent(element, name, callback ){
				//touch gestures must be disabled when ligthbox is opened
				Scheduler.eventObject._attachDomEvent(element, name, function( e ){
					if( scheduler._is_lightbox_open() ){
						return true;
					} else {
						return callback( e );
					}
				});
			}

			function check_direction_swipe(s_ev, e_ev, step, max_dy ){
				if( !s_ev || !e_ev) return;

				var t = s_ev.target;
				while( t && t !== scheduler._obj ){
					t = t.parentNode;
				}
				if( t !== scheduler._obj ){
					//swipe outside scheduler
					return;
				}

				var dy = Math.abs(s_ev.pageY - e_ev.pageY);
				var dx = Math.abs(s_ev.pageX - e_ev.pageX);
				if( dy < max_dy && dx > step && (!dy || (dx / dy > 3)) ){
					if( s_ev.pageX > e_ev.pageX)
						scheduler._click.sdr_cal_next_button();
					else
						scheduler._click.sdr_cal_prev_button();
				}
			}

			function doMouseMove(e ){
				var dnd = scheduler.getState().drag_mode,
					timeline = scheduler.matrix ? scheduler.matrix[scheduler._mode] : false;

				var original_render = scheduler.render_view_data;
				if( dnd === 'create' && timeline ){
					//suppress full redraw of timeline on creating event
					scheduler.render_view_data = function(){
						var id = scheduler.getState().drag_id;
						var ev = scheduler.getEvent( id );
						var property = timeline.y_property;

						var evs = scheduler.getEvents(ev.start_date, ev.end_date);
						for( var i = 0; i < evs.length; i++ ){
							if( evs[ i ][property] !== ev[property] ){
								evs.splice(i, 1);
								i--;
							}
						}
						ev._sorder = evs.length - 1;
						ev._count = evs.length;

						this.render_data([ev], scheduler.getState().mode);
					};
				}

				scheduler._on_mouse_move( e );

				if( dnd === "create" && timeline ){
					scheduler.render_view_data = original_render;
				}
			}

			attachTouchEvent(document.body, names[ 0 ], function( e ){
				if( ignore( e )) return;

				if( drag_mode ){
					doMouseMove(accessor( e ));
					scheduler._update_global_tip();
					if( e.preventDefault)
						e.preventDefault();
					e.cancelBubble = true;
					return false;
				}

				tracker = accessor( e );

				//ignore common and scrolling moves
				if( !action_mode) return;

				//multitouch
				if( !tracker ){
					scroll_mode = true;
					return;
				}

				//target changed - probably in scroll mode
				if( source.target !== tracker.target || (Math.abs(source.pageX - tracker.pageX) > 5) || (Math.abs(source.pageY - tracker.pageY) > 5) ){
					scroll_mode = true;
					clearTimeout(timer);
				}
			});

			attachTouchEvent( this._els["sdr_cal_data"][ 0 ], "scroll", drag_cancel);
			attachTouchEvent( this._els["sdr_cal_data"][ 0 ], "touchcancel", drag_cancel);
			attachTouchEvent( this._els["sdr_cal_data"][ 0 ], "contextmenu", function( e ){
				if( action_mode ){
					if( e && e.preventDefault) e.preventDefault();
					(e || event).cancelBubble = true;
					return false;
				}
			});
			attachTouchEvent( this._els["sdr_cal_data"][ 0 ], names[ 1 ], function( e ){
				if( ignore( e )) return;

				var fake_event;
				drag_mode = scroll_mode = false;
				action_mode = true;
				scheduler._temp_touch_block = true;
				fake_event = tracker = accessor( e );

				if( !fake_event ){
					scroll_mode = true;
					return;
				}

				//dbl click
				var now = new Date();

				if( !scroll_mode && !drag_mode && now - dblclicktime < 250 ){
					scheduler._click.sdr_cal_data(fake_event);
					setTimeout(function(){
						scheduler._on_dbl_click(fake_event);
					}, 50);

					if( e.preventDefault)
						e.preventDefault();
					e.cancelBubble = true;
					scheduler._block_next_stop = true;
					return false;
				}
				dblclicktime = now;

				//drag
				if( scroll_mode || drag_mode || !scheduler.config.touch_drag) return;

				var actTask = scheduler._locate_event(document.activeElement);
				var fakeTask = scheduler._locate_event(fake_event.target);
				var sourceTask = source ? scheduler._locate_event(source.target) : null;

				if( actTask && fakeTask && actTask === fakeTask && actTask !== sourceTask ){
					if( e.preventDefault ){
						e.preventDefault();
					}
					e.cancelBubble = true;
					scheduler._ignore_next_click = false;
					scheduler._click.sdr_cal_data(fake_event);
					source = fake_event;
					return false;
				}

				//there is no target
				timer = setTimeout(function(){
					drag_mode = true;
					var target = source.target;
					if( target && target.className && target.className.indexOf("sdr_body") !== -1 ){
						target = target.previousSibling;
					}
					scheduler._on_mouse_down(source, target);
					if( scheduler._drag_mode && scheduler._drag_mode !== "create" ){
						scheduler.for_rendered(scheduler._drag_id, function( node, i ){
							node.style.display = 'none';
							scheduler._rendered.splice(i, 1);
						});
					}

					if( scheduler.config.touch_tip ){
						scheduler._show_global_tip();
					}
					scheduler._on_mouse_move(source);
				}, scheduler.config.touch_drag);

				source = fake_event;
			});
			attachTouchEvent( this._els["sdr_cal_data"][ 0 ], names[ 2 ], function( e ){
				if( ignore( e )) return;

				if( !drag_mode)
					check_direction_swipe(source, tracker, 200, 100);

				if( drag_mode)
					scheduler._ignore_next_click = true;

				drag_cancel( e );
				if( scheduler._block_next_stop ){
					scheduler._block_next_stop = false;
					if( e.preventDefault) e.preventDefault();
					e.cancelBubble = true;
					return false;
				}
			});

			function drag_cancel(e ){
				scheduler._hide_global_tip();
				if( drag_mode ){
					scheduler._on_mouse_up(accessor(e || event));
					scheduler._temp_touch_block = false;
				}
				scheduler._drag_id = null;
				scheduler._drag_mode = null;
				scheduler._drag_pos = null;

				clearTimeout(timer);
				drag_mode = action_mode = false;
				scroll_mode = true;
			}

			Scheduler.eventObject._attachDomEvent(document.body, names[ 2 ], drag_cancel);
		};
		//for mobile & touch devices
		scheduler._show_global_tip = function(){
			scheduler._hide_global_tip();

			var tip = scheduler._global_tip = document.createElement( "DIV" );
			tip.className = "sdr_global_tip";

			scheduler._update_global_tip(1);

			document.body.appendChild(tip);
		};
		//for mobile & touch devices
		scheduler._update_global_tip = function( init ){
			var tip = scheduler._global_tip;
			if( tip ){
				var time = "";
				if( scheduler._drag_id && !init ){
					var ev = scheduler.getEvent(scheduler._drag_id);
					if( ev)
						time = "<div>" + (ev._timed ? scheduler.templates.event_header(ev.start_date, ev.end_date, ev) : scheduler.templates.day_date(ev.start_date, ev.end_date, ev)) + "</div>";
				}

				if( scheduler._drag_mode === "create" || scheduler._drag_mode === "new-size")
					tip.innerHTML = (scheduler.locale.drag_to_create || "Drag to create") + time;
				else
					tip.innerHTML = (scheduler.locale.drag_to_move || "Drag to move") + time;
			}
		};
		//for mobile & touch devices
		scheduler._hide_global_tip = function(){
			var tip = scheduler._global_tip;
			if( tip && tip.parentNode ){
				tip.parentNode.removeChild(tip);
				scheduler._global_tip = 0;
			}
		};


		/*** skin init ***/
		scheduler._skin_init = function(){

			scheduler.templates.event_bar_date = function( start, end, ev ){
				//return "• <b>" + scheduler.templates.event_date( start ) + "</b> ";
				return ev.changed ? "‣ " : "• ";
			};

			scheduler.attachEvent("onTemplatesReady", function(){

				var date_to_str = scheduler.date.date_to_str("%d" );
				if( !scheduler.templates._old_month_day ){
					scheduler.templates._old_month_day = scheduler.templates.month_day;
				}
				var old_month_day = scheduler.templates._old_month_day;
				scheduler.templates.month_day = function( date ){
					if( this._mode === "month" ){
						var label = date_to_str(date);
						if( date.getDate() === 1 ){
							label = scheduler.locale.date.month_full[date.getMonth()] + " " + label;
						}
						if( +date === +scheduler.date.date_part( new Date() ) ){
							label = scheduler.locale.labels.sdr_cal_today_button + " " + label;
						}
						return label;
					} else {
						return old_month_day.call(this, date);
					}
				};

				if( scheduler.config.fix_tab_position ){
					var navline_divs = scheduler._els[ "sdr_cal_navline" ][ 0 ].getElementsByTagName('div');
					var last = 258;
					for( var i = 0; i < navline_divs.length; i++ ){
						var div = navline_divs[ i ];
						var name = div.getAttribute("data-name" );
						if( name ){//mode tab
							div.style.right = "auto";
							switch( name ){
								//left ++ 61px
								case "day_tab":
									div.style.left = "14px";
									div.className += " sdr_cal_tab_first";
									break;
								case "week_tab":
									div.style.left = "75px";
									break;
								case "month_tab":
									div.style.left = "136px";
									break;
								case "year_tab":
									div.style.left = "197px";
									break;
								case "list_tab":
									div.style.left = "258px";
									div.className += " sdr_cal_tab_last";
									break;
								default:
									div.style.left = last + "px";
									div.className += " sdr_cal_tab_standalone";
									last = last + 14 + div.offsetWidth;
									break;
							}
						}
					}
				}

			});

			//reset self function
			scheduler._skin_init = function(){
			};
		};


		/*** recurring ***/
		scheduler.form_blocks[ "recurring" ] = {
			_get_node : function( node ){
				if( typeof node === "string")
					node = document.getElementById( node );
				if( node.style.display === 'none')
					node.style.display = "";
				return node;
			},
			_outer_html : function( node ){
				return node.outerHTML || getOuterHTML( node );

				//probably not needed, FF v10- only
				function getOuterHTML(n ){
					var div = document.createElement( "DIV" ), h;
					div.appendChild(n.cloneNode( true ));
					h = div.innerHTML;
					div = null;
					return h;
				}
			},
			render : function( sns ){
				if( sns.form ){
					var rec = scheduler.form_blocks[ "recurring" ];
					var form = rec._get_node(sns.form);
					var html = rec._outer_html(form);
					form.style.display = 'none';
					return html;
				}

				return scheduler.__recurring_template;

			},
			_ds : {},
			_get_form_node : function( els, name, value ){
				var col = els[ name ];
				if( !col) return null;
				if( col.nodeName) return col;

				if( col.length ){
					for( var i = 0; i < col.length; i++ ){
						if( col[ i ].value === value)
							return col[ i ];
					}
				}
			},
			_get_node_value : function( els, name, multiselect ){
				var col = els[ name ];
				if( !col) return "";
				if( col.length ){
					if( multiselect ){
						var res = [];
						for( var i = 0; i < col.length; i++ )
							if( col[ i ].checked) res.push(col[ i ].value);

						return res;
					} else {
						for( var i = 0; i < col.length; i++ )
							if( col[ i ].checked) return col[ i ].value;
					}
				}

				if( col.value)
					return !multiselect ? col.value : [col.value];
			},
			_set_node_value : function( els, name, value ){
				var col = els[ name ];
				if( !col) return;

				if( col.name === name ){
					col.value = value;
				} else if( col.length ){
					var hash_value = typeof value === "object";
					for( var i = 0; i < col.length; i++ )
						if( hash_value || col[ i ].value === value ){
							col[ i ].checked = hash_value ? !!value[col[ i ].value] : !!value;
						}
				}
			},
			_init_set_value : function( node, value, ev ){
				var block = scheduler.form_blocks[ "recurring" ];
				var get_value = block._get_node_value;
				var set_value = block._set_node_value;
				scheduler.form_blocks[ "recurring" ]._ds = {start : ev.start_date, end : ev._end_date};

				var str_date_format = scheduler.date.str_to_date(scheduler.config.repeat_date);
				var str_date = function( str_date ){
					var date = str_date_format(str_date);
					if( scheduler.config.include_end_by)
						date = scheduler.date.add(date, 1, 'day');
					return date;
				};

				var date_str = scheduler.date.date_to_str(scheduler.config.repeat_date);

				var top = node.getElementsByTagName("FORM")[ 0 ];
				var els = {};

				function register_els(inps ){
					for( var i = 0; i < inps.length; i++ ){
						var inp = inps[ i ];

						if( inp.name ){
							if( !els[inp.name] ){
								els[inp.name] = inp;
							} else if( els[inp.name].nodeType ){
								var node = els[inp.name];
								els[inp.name] = [node, inp];

							} else {
								els[inp.name].push(inp);
							}

						}
					}
				}

				register_els(top.getElementsByTagName("INPUT"));
				register_els(top.getElementsByTagName("SELECT"));

				if( !scheduler.config.repeat_date_of_end ){
					var formatter = scheduler.date.date_to_str(scheduler.config.repeat_date);
					scheduler.config.repeat_date_of_end = formatter(scheduler.date.add(scheduler._currentDate(), 30, "day"));
				}
				set_value( els, "date_of_end", scheduler.config.repeat_date_of_end);

				var $ = function( a ){
					return document.getElementById(a) || {style : {}};//return fake object if node not found
				};

				function change_current_view(){
					$("sdr_repeat_day").style.display = "none";
					$("sdr_repeat_week").style.display = "none";
					$("sdr_repeat_month").style.display = "none";
					$("sdr_repeat_year").style.display = "none";
					$("sdr_repeat_" + this.value).style.display = "block";
					scheduler.setLightboxSize();
				}

				function get_repeat_code(dates ){
					var code = [get_value( els, "repeat")];
					get_rcode[code[ 0 ]](code, dates);

					while( code.length < 5) code.push("" );
					var repeat = "";

					var end = get_end_rule( els);

					if( end === "no" ){
						dates.end = new Date(9999, 1, 1);
						repeat = "no";
					}
					else if( end === "date_of_end" ){
						dates.end = str_date(get_value( els, "date_of_end"));
					}
					else {
						scheduler.transpose_type(code.join("_"));
						repeat = Math.max(1, get_value( els, "occurences_count"));

						var transp = 0;

						dates.end = scheduler.date.add(new Date(dates.start), repeat + transp, code.join("_"));
					}

					return code.join("_") + "#" + repeat;
				}

				function get_end_rule( els ){
					var end = els["end"];
					if( end.length ){
						for( var i = 0; i < end.length; i++ ){
							if( end[ i ].checked ){
								if( end[ i ].value && end[ i ].value !== "on" ){//seems to be default value:var input = document.createElement("input" ); input.type = "radio"; input.value
									return end[ i ].value;
								} else {
									if( !i ){
										return "no";
									} else if( i === 2 ){
										return "date_of_end";
									} else {
										return "occurences_count";
									}
								}
							}
						}
					} else {
						if( end.value)
							return end.value;
					}
					return "no";
				}

				function set_end_rule( els, value ){
					var end = els["end"];

					if( end.length ){
						var has_values = !!end[ 0 ].value && end[ 0 ].value !== "on";
						if( has_values ){
							for( var i = 0; i < end.length; i++ ){
								if( end[ i ].value === value)
									end[ i ].checked = true;
							}
						} else {
							var ind = 0;
							switch( value ){
								case "no":
									ind = 0;
									break;
								case "date_of_end":
									ind = 2;
									break;
								default:
									ind = 1;
									break;
							}
							end[ind].checked = true;
						}
					} else {
						end.value = value;
					}
				}

				scheduler.form_blocks[ "recurring" ]._get_repeat_code = get_repeat_code;

				var get_rcode = {
					month : function( code, dates ){
						var get_value = scheduler.form_blocks[ "recurring" ]._get_node_value;
						if( get_value( els, "month_type") === "d" ){
							code.push(Math.max(1, get_value( els, "month_count")));
							dates.start.setDate(get_value( els, "month_day"));
						} else {
							code.push(Math.max(1, get_value( els, "month_count2")));
							code.push(get_value( els, "month_day2"));
							code.push(Math.max(1, get_value( els, "month_week2")));
							if( !scheduler.config.repeat_precise ){
								dates.start.setDate(1);
							}
						}
						dates._start = true;
					},
					week : function( code, dates ){
						var get_value = scheduler.form_blocks[ "recurring" ]._get_node_value;

						code.push(Math.max(1, get_value( els, "week_count")));
						code.push("" );
						code.push("" );
						var t = [];

						var col = get_value( els, "week_day", true);
						//var col = els["week_day"];
						var day = dates.start.getDay();
						var start_exists = false;

						for( var i = 0; i < col.length; i++ ){
							t.push(col[ i ] );
							start_exists = start_exists || col[ i ] === day;
						}
						if( !t.length ){
							t.push( day );
							start_exists = true;
						}
						t.sort();


						if( !scheduler.config.repeat_precise ){
							dates.start = scheduler.date.week_start(dates.start);
							dates._start = true;
						} else if( !start_exists ){
							scheduler.transpose_day_week(dates.start, t, 1, 7);
							dates._start = true;
						}

						code.push(t.join(","));
					},
					day : function( code ){
						var get_value = scheduler.form_blocks[ "recurring" ]._get_node_value;

						if( get_value( els, "day_type") === "d" ){
							code.push(Math.max(1, get_value( els, "day_count")));
						}
						else {
							code.push("week" );
							code.push(1);
							code.push("" );
							code.push("" );
							code.push(scheduler.config.recurring_workdays.join(","));
							code.splice(0, 1);
						}
					},
					year : function( code, dates ){
						var get_value = scheduler.form_blocks[ "recurring" ]._get_node_value;

						if( get_value( els, "year_type") === "d" ){
							code.push("1" );
							dates.start.setMonth( 0 );
							dates.start.setDate(get_value( els, "year_day"));
							dates.start.setMonth(get_value( els, "year_month"));

						} else {
							code.push("1" );
							code.push(get_value( els, "year_day2"));
							code.push(get_value( els, "year_week2"));
							dates.start.setDate(1);
							dates.start.setMonth(get_value( els, "year_month2"));
						}
						dates._start = true;
					}
				};
				var set_rcode = {
					week : function( code, dates )
					{
						var set_value = scheduler.form_blocks[ "recurring" ]._set_node_value;
						set_value( els, "week_count", code[ 1 ] );

						var t = code[ 4 ].split("," );
						var d = {};
						for( var i = 0; i < t.length; i++ ) d[t[ i ]] = true;

						set_value( els, "week_day", d);

						//for( var i = 0; i < col.length; i++ )
						//	col[ i ].checked = (!!d[col[ i ].value] );
					},
					month : function( code, dates )
					{
						var set_value = scheduler.form_blocks[ "recurring" ]._set_node_value;

						if( code[ 2 ] === "" )
						{
							set_value( els, "month_type", "d" );
							set_value( els, "month_count", code[ 1 ] );
							set_value( els, "month_day", dates.start.getDate() );
						}
						else
						{
							set_value( els, "month_type", "w" );
							set_value( els, "month_count2", code[ 1 ] );
							set_value( els, "month_week2", code[ 3 ] );
							set_value( els, "month_day2", code[ 2 ] );
						}
					},
					day : function( code, dates )
					{
						var set_value = scheduler.form_blocks[ "recurring" ]._set_node_value;
						set_value( els, "day_type", "d" );
						set_value( els, "day_count", code[ 1 ] );
					},
					year : function( code, dates )
					{
						var set_value = scheduler.form_blocks[ "recurring" ]._set_node_value;

						if( code[ 2 ] === "" )
						{
							set_value( els, "year_type", "d" );
							set_value( els, "year_day", dates.start.getDate() );
							set_value( els, "year_month", dates.start.getMonth() );
						}
						else
						{
							set_value( els, "year_type", "w" );
							set_value( els, "year_week2", code[ 3 ] );
							set_value( els, "year_day2", code[ 2 ] );
							set_value( els, "year_month2", dates.start.getMonth() );
						}
					}
				};

				function set_repeat_code(code, dates )
				{
					var set_value = scheduler.form_blocks[ "recurring" ]._set_node_value;
					var data = code.split( "#" );
					code = data[ 0 ].split( "_" );
					set_rcode[code[ 0 ]](code, dates);

					switch( data[ 1 ] )
					{
						case "no" : set_end_rule( els, "no" ); break;
						case "" :
							set_end_rule( els, "date_of_end" );

							var end_date = dates.end;
							if( scheduler.config.include_end_by ) end_date = scheduler.date.add(end_date, -1, 'day');
							set_value( els, "date_of_end", date_str( end_date ));
						break;

						default :
							set_end_rule( els, "occurences_count" );
							set_value( els, "occurences_count", data[ 1 ] );
						break;
					}

					set_value( els, "repeat", code[ 0 ] );
					//e.checked = true;

					var node = scheduler.form_blocks[ "recurring" ]._get_form_node( els, "repeat", code[ 0 ] );
					if( node.nodeName === "SELECT" && node.onchange ) node.onchange();
					else if( node.onclick ) node.onclick();
				}

				scheduler.form_blocks[ "recurring" ]._set_repeat_code = set_repeat_code;

				for( var i = 0; i < top.elements.length; i++ )
				{
					var el = top.elements[ i ];
					switch( el.name )
					{
						case "repeat" :
							if( el.nodeName === "SELECT" ) el.onchange = change_current_view;
							else el.onclick = change_current_view;
						break;
					}
				}
				scheduler._lightbox._rec_init_done = true;
			},
			set_value : function( node, value, ev )
			{
				var rf = scheduler.form_blocks[ "recurring" ];
				if( !scheduler._lightbox._rec_init_done ) rf._init_set_value(node, value, ev);
				node.open = !ev.rec_type;
				if( this._is_modified_occurence( ev ) ) node.blocked = true;
				else node.blocked = false;

				var ds = rf._ds;
					ds.start = ev.start_date;
					ds.end = ev._end_date;

				rf.button_click( 0, node.previousSibling.firstChild.firstChild, node, node );
				if( value ) rf._set_repeat_code(value, ds);
			},
			get_value : function( node, ev )
			{
				if( node.open )
				{
					var ds = scheduler.form_blocks[ "recurring" ]._ds;
					var actual_dates = {};
					this.formSection( 'time' ).getValue(actual_dates);
					ds.start = actual_dates.start_date;
					ev.rec_type = scheduler.form_blocks[ "recurring" ]._get_repeat_code( ds );
					if( ds._start )
					{
						ev.start_date = new Date( ds.start );
						ev._start_date = new Date( ds.start );
						ds._start = false;
					}
					else ev._start_date = null;

					ev._end_date = ds.end;
					ev.rec_pattern = ev.rec_type.split( "#" )[ 0 ];
				}
				else
				{
					ev.rec_type = ev.rec_pattern = "";
					ev._end_date = ev.end_date;
				}
				return ev.rec_type;
			},
			_get_button : function()
			{
				var node = scheduler.formSection( "recurring" ).header;
				return node.firstChild.firstChild;
			},
			_get_form : function(){ return scheduler.formSection( "recurring" ).node; },
			open : function()
			{
				var block = scheduler.form_blocks.recurring;
				var cont = block._get_form();
				if( !cont.open ) block._toggle_block();
			},
			close : function()
			{
				var block = scheduler.form_blocks.recurring;
				var cont = block._get_form();
				if( cont.open ) block._toggle_block();
			},
			_toggle_block : function()
			{
				var block = scheduler.form_blocks.recurring;

				var cont = block._get_form(),
					el = block._get_button();
				if( !cont.open && !cont.blocked )
				{
					cont.style.height = "auto";//reset to default value;
					if( el )
					{
						el.style.backgroundPosition = "-5px 0px";
						el.nextSibling.innerHTML = scheduler.locale.labels.button_recurring_open;
					}
				}
				else
				{
					cont.style.height = "0px";
					if( el )
					{
						el.style.backgroundPosition = "-5px 20px";
						el.nextSibling.innerHTML = scheduler.locale.labels.button_recurring;
					}
				}
				cont.open = !cont.open;

				scheduler.setLightboxSize();
			},
			focus : function( node ){},
			button_click : function( index, el, section, cont ){ scheduler.form_blocks.recurring._toggle_block(); }
		};


		//problem may occur if we will have two repeating events in the same moment of time;
		scheduler._rec_markers = {};
		scheduler._rec_markers_pull = {};
		scheduler._rec_temp = [];
		scheduler._add_rec_marker = function( ev, time )
		{
			ev._pid_time = time;
			this._rec_markers[ev.id] = ev;
			if( !this._rec_markers_pull[ ev.event_pid ] ) this._rec_markers_pull[ ev.event_pid ] = {};
			this._rec_markers_pull[ ev.event_pid ][ time ] = ev;
		};
		scheduler._get_rec_marker = function( time, id )
		{
			var ch = this._rec_markers_pull[ id ];
			if( ch) return ch[ time ];
			return null;
		};
		scheduler._get_rec_markers = function( id ){ return (this._rec_markers_pull[ id ] || [] ); };

		scheduler.attachEvent("onEventIdChange", function( id, new_id )
		{
			if( this._ignore_call) return;
			this._ignore_call = true;

			if( scheduler._rec_markers[ id ] )
			{
				//important for for correct work of scheduler.getEvents(from, to) and collision detection;
				scheduler._rec_markers[new_id] = scheduler._rec_markers[ id ];
				delete scheduler._rec_markers[ id ];
			}

			for( var i = 0; i < this._rec_temp.length; i++ )
			{
				var tev = this._rec_temp[ i ];
				if( tev.event_pid === id )
				{
					tev.event_pid = new_id;
					this.changeEventId(tev.id, new_id + "#" + tev.id.split( "#" )[ 1 ] );
				}
			}

			delete this._ignore_call;
		});
		scheduler.attachEvent("onConfirmedBeforeEventDelete", function( id ){
			var ev = this.getEvent( id );
			if( this._is_virtual_event( id ) || (this._is_modified_occurence( ev ) && ev.rec_type && ev.rec_type !== 'none') ){
				id = id.split( "#" );
				var nid = this.uid();
				var tid = (id[ 1 ]) ? id[ 1 ] : (ev._pid_time / 1000);

				var nev = this._copy_event( ev );
				nev.id = nid;
				nev.event_pid = ev.event_pid || id[ 0 ];
				var timestamp = tid;
				nev.event_length = timestamp;
				nev.rec_type = nev.rec_pattern = "none";
				this.addEvent(nev);

				this._add_rec_marker(nev, timestamp * 1000);
			}
			else
			{
				if( ev.rec_type && this._lightbox_id ) this._roll_back_dates( ev );
				var sub = this._get_rec_markers( id );
				for( var i in sub )
				{
					if( sub.hasOwnProperty( i ) )
					{
						id = sub[ i ].id;
						if( this.getEvent( id ) ) this.deleteEvent(id, true);
					}
				}
			}
			return true;
		});

		scheduler.attachEvent("onEventDeleted", function( id, ev ){
			if( !this._is_virtual_event( id ) && this._is_modified_occurence( ev ) )
			{
				if( !scheduler._events[ id ] )
				{
					ev.rec_type = ev.rec_pattern = "none";
					this.setEvent(id, ev);
				}
			}
		});

		scheduler.attachEvent("onEventChanged", function( id )
		{
			if( this._loading) return true;

			var ev = this.getEvent( id );

			if( this._is_virtual_event( id ) )
			{
				var id = id.split( "#" );
				var nid = this.uid();
				this._not_render = true;

				var nev = this._copy_event( ev );
				nev.id = nid;
				nev.event_pid = id[ 0 ];
				var timestamp = id[ 1 ];
				nev.event_length = timestamp;
				nev.rec_type = nev.rec_pattern = "";

				this._add_rec_marker(nev, timestamp * 1000);
				this.addEvent(nev);

				this._not_render = false;

			}
			else
			{
				if( ev.rec_type && this._lightbox_id ) this._roll_back_dates( ev );
				var sub = this._get_rec_markers( id );
				for( var i in sub )
				{
					if( sub.hasOwnProperty( i ) )
					{
						delete this._rec_markers[sub[ i ].id ];
						this.deleteEvent(sub[ i ].id, true );
					}
				}
				delete this._rec_markers_pull[ id ];

				//it's possible that after editing event is no longer exists, in such case we need to remove _select_id flag;
				var isEventFound = false;
				for( var k = 0; k < this._rendered.length; k++ )
				{
					if( this._rendered[ k ].getAttribute('data-event-id') === id )
						isEventFound = true;
				}
				if( !isEventFound ) this._select_id = null;
			}
			return true;
		});
		scheduler.attachEvent("onEventAdded", function( id )
		{
			if( !this._loading )
			{
				var ev = this.getEvent( id );
				if( ev.rec_type && !ev.event_length ) this._roll_back_dates( ev );
			}
			return true;
		});
		scheduler.attachEvent("onEventSave", function( id, data, is_new_event ){
			var ev = this.getEvent( id );
			if( !ev.rec_type && data.rec_type && !this._is_virtual_event( id ) ) this._select_id = null;
			return true;
		});
		scheduler.attachEvent("onEventCreated", function( id ){
			var ev = this.getEvent( id );
			if( !ev.rec_type ) ev.rec_type = ev.rec_pattern = ev.event_length = ev.event_pid = "";
			return true;
		});
		scheduler.attachEvent("onEventCancel", function( id ){
			var ev = this.getEvent( id );
			if( ev.rec_type )
			{
				this._roll_back_dates( ev );
				this.render_view_data();
			}
		});

		scheduler._roll_back_dates = function( ev )
		{
			ev.event_length = (ev.end_date.valueOf() - ev.start_date.valueOf()) / 1000;
			ev.end_date = ev._end_date;
			if( ev._start_date )
			{
				ev.start_date.setMonth( 0 );
				ev.start_date.setDate(ev._start_date.getDate() );
				ev.start_date.setMonth(ev._start_date.getMonth() );
				ev.start_date.setFullYear(ev._start_date.getFullYear() );
			}
		};

		scheduler._is_virtual_event = function( id ){ return id.toString().indexOf( "#" ) !== -1; };
		scheduler._is_modified_occurence = function( ev ){ return (ev.event_pid && ev.event_pid !== "0" ); };

		//override function;
		scheduler.showLightbox_rec = scheduler.showLightbox;
		scheduler.showLightbox = function( id )
		{
			var locale = this.locale;
			var c = scheduler.config.lightbox_recurring;
			var ev = this.getEvent( id );
			var pid = ev.event_pid;
			var isVirtual = this._is_virtual_event( id );
			if( isVirtual) pid = id.split( "#" )[ 0 ];

			//show series;
			var showSeries = function( id )
			{
				var event = scheduler.getEvent( id );
				event._end_date = event.end_date;
				event.end_date = new Date(event.start_date.valueOf() + event.event_length * 1000 );
				return scheduler.showLightbox_rec( id );//editing series;
			};

			if( (pid || pid * 1 === 0) && ev.rec_type )
			{
				//direct API call on series id
				return showSeries( id );
			}

			if( !pid || pid === '0' || ( (!locale.labels.confirm_recurring || c === 'instance') || (c === 'series' && !isVirtual)) )
			{
				//editing instance or non recurring event
				return this.showLightbox_rec( id );
			}

			if( c === 'ask' )
			{
				var that = this;
				Scheduler.component.modalbox({
					text : locale.labels.confirm_recurring
					, title : locale.labels.title_confirm_recurring
					, width : "500px"
					, position : "middle"
					, buttons : [locale.labels.button_edit_series, locale.labels.button_edit_occurrence, locale.labels.icon_cancel]
					, callback : function( index ){
						switch( +index )
						{
							case 0 : return showSeries( pid );
							case 1 : return that.showLightbox_rec( id );
							case 2 : return;
						}
					}
				});
			}
			else showSeries( pid );
		};

		//override function;
		scheduler.get_visible_events_rec = scheduler.get_visible_events;
		scheduler.get_visible_events = function( only_timed )
		{
			for( var i = 0; i < this._rec_temp.length; i++ ) delete this._events[this._rec_temp[ i ].id];
			this._rec_temp = [];

			var stack = this.get_visible_events_rec(only_timed);
			var out = [];
			for( var i = 0; i < stack.length; i++ )
			{
				if( stack[ i ].rec_type )
				{
					//deleted element of serie;
					if( stack[ i ].rec_pattern !== "none" ) this.repeat_date(stack[ i ], out);
				}
				else out.push(stack[ i ] );
			}
			return out;
		};

		scheduler.transpose_day_week = function( sd, list, cor, size, cor2 )
		{
			var cday = (sd.getDay() || (scheduler.config.start_on_monday ? 7 : 0)) - cor;
			for( var i = 0; i < list.length; i++ )
				if( list[ i ] > cday ) return sd.setDate(sd.getDate() + list[ i ] * 1 - cday - (size ? cor : cor2));

			this.transpose_day_week(sd, list, cor + size, null, cor);
		};

		scheduler.transponse_size = { day : 1, week : 7, month : 1, year : 12 };

		scheduler.transpose_type = function( type )
		{
			var f = "transpose_" + type;
			if( !this.date[ f ] )
			{
				var str = type.split( "_" );
				var day = 60 * 60 * 24 * 1000;
				var gf = "add_" + type;
				var step = this.transponse_size[str[ 0 ]] * str[ 1 ];

				if( str[ 0 ] === "day" || str[ 0 ] === "week" )
				{
					var days = null;
					if( str[ 4 ] )
					{
						days = str[ 4 ].split("," );
						if( scheduler.config.start_on_monday )
						{
							for( var i = 0; i < days.length; i++ ) days[ i ] = (days[ i ] * 1) || 7;
							days.sort();
						}
					}

					this.date[ f ] = function( nd, td )
					{
						var delta = Math.floor((td.valueOf() - nd.valueOf()) / (day * step));
						if( delta > 0 ) nd.setDate(nd.getDate() + delta * step);
						if( days ) scheduler.transpose_day_week(nd, days, 1, step);
					};
					this.date[ gf ] = function( sd, inc )
					{
						var nd = new Date(sd.valueOf() );
						if( days )
						{
							for( var count = 0; count < inc; count++ ) scheduler.transpose_day_week(nd, days, 0, step);
						}
						else nd.setDate(nd.getDate() + inc * step);

						return nd;
					};
				}
				else if( str[ 0 ] === "month" || str[ 0 ] === "year" )
				{
					this.date[ f ] = function( nd, td )
					{
						var delta = Math.ceil(((td.getFullYear() * 12 + td.getMonth() * 1) - (nd.getFullYear() * 12 + nd.getMonth() * 1)) / (step));
						if( delta >= 0 ) nd.setMonth(nd.getMonth() + delta * step);
						if( str[ 3 ] ) scheduler.date.day_week(nd, str[ 2 ], str[ 3 ] );
					};
					this.date[ gf ] = function( sd, inc )
					{
						var nd = new Date(sd.valueOf() );
						nd.setMonth( nd.getMonth() + inc * step );
						if( str[ 3 ] ) scheduler.date.day_week(nd, str[ 2 ], str[ 3 ] );
						return nd;
					};
				}
			}
		};

		scheduler.repeat_date = function( ev, stack, non_render, from, to )
		{
			from = from || this._min_date;
			to = to || this._max_date;

			var td = new Date(ev.start_date.valueOf() );

			if( !ev.rec_pattern && ev.rec_type ) ev.rec_pattern = ev.rec_type.split( "#" )[ 0 ];

			this.transpose_type(ev.rec_pattern);
			scheduler.date["transpose_" + ev.rec_pattern](td, from);

			while( td < ev.start_date || scheduler._fix_daylight_saving_date(td, from, ev, td, new Date(td.valueOf() + ev.event_length * 1000)).valueOf() <= from.valueOf() || td.valueOf() + ev.event_length * 1000 <= from.valueOf() )
				td = this.date.add(td, 1, ev.rec_pattern);

			while( td < to && td < ev.end_date )
			{
				var timestamp = (scheduler.config.occurrence_timestamp_in_utc) ? Date.UTC(td.getFullYear(), td.getMonth(), td.getDate(), td.getHours(), td.getMinutes(), td.getSeconds()) : td.valueOf();
				var ch = this._get_rec_marker(timestamp, ev.id);
				if( !ch )//unmodified element of series;
				{
					var ted = new Date(td.valueOf() + ev.event_length * 1000);
					var copy = this._copy_event( ev );
					//copy._timed = ev._timed;
					copy.text = ev.text;
					copy.start_date = td;
					copy.event_pid = ev.id;
					copy.id = ev.id + "#" + Math.ceil(timestamp / 1000);
					copy.end_date = ted;
					copy.end_date = scheduler._fix_daylight_saving_date(copy.start_date, copy.end_date, ev, td, copy.end_date);
					copy._timed = this.isOneDayEvent( copy );

					if( !copy._timed && !this._table_view && !this.config.multi_day) return;
					stack.push( copy );

					if( !non_render )
					{
						this._events[copy.id] = copy;
						this._rec_temp.push( copy );
					}
				}
				else
				{
					if( non_render) stack.push( ch );
				}
				td = this.date.add(td, 1, ev.rec_pattern);
			}
		};

		scheduler._fix_daylight_saving_date = function( start_date, end_date, ev, counter, default_date )
		{
			var shift = start_date.getTimezoneOffset() - end_date.getTimezoneOffset();
			if( shift )
			{
				if( shift > 0 )
				{
					//e.g. 24h -> 23h
					return new Date(counter.valueOf() + ev.event_length * 1000 - shift * 60 * 1000);
				}
				else
				{
					//e.g. 24h -> 25h
					return new Date(end_date.valueOf() - shift * 60 * 1000);
				}
			}
			return new Date(default_date.valueOf() );
		};

		scheduler.getRecDates = function( id, max )
		{
			var ev = typeof id === "object" ? id : scheduler.getEvent( id );
			var count = 0;
			var result = [];
			max = max || 100;

			var td = new Date(ev.start_date.valueOf() );
			var from = new Date(td.valueOf() );

			if( !ev.rec_type ) return [ { start_date : ev.start_date, end_date : ev.end_date } ];
			if( ev.rec_type === "none" ) return [];

			this.transpose_type(ev.rec_pattern);
			scheduler.date["transpose_" + ev.rec_pattern](td, from);

			while( td < ev.start_date || (td.valueOf() + ev.event_length * 1000) <= from.valueOf() )
				td = this.date.add(td, 1, ev.rec_pattern);

			while( td < ev.end_date )
			{
				var ch = this._get_rec_marker(td.valueOf(), ev.id);
				var res = true;
				if( !ch )//unmodified element of series;
				{
					var sed = new Date( td );
					var ted = new Date(td.valueOf() + ev.event_length * 1000);

					ted = scheduler._fix_daylight_saving_date(sed, ted, ev, td, ted);

					result.push({start_date : sed, end_date : ted});
				}
				else if( ch.rec_type === "none" ) res = false;
				else result.push({start_date : ch.start_date, end_date : ch.end_date});

				td = this.date.add(td, 1, ev.rec_pattern);
				if( res )
				{
					count++;
					if( count === max) break;
				}
			}
			return result;
		};

		scheduler.getEvents = function( from, to )
		{
			var result = [];
			for( var a in this._events )
			{
				var ev = this._events[ a ];
				if( ev && ev.start_date < to && ev.end_date > from )
				{
					if( ev.rec_pattern )
					{
						if( ev.rec_pattern === "none") continue;
						var sev = [];
						this.repeat_date(ev, sev, true, from, to);
						for( var i = 0; i < sev.length; i++ )
						{
							//if event is in rec_markers then it will be checked by himself, here need to skip it;
							if( !sev[ i ].rec_pattern && sev[ i ].start_date < to && sev[ i ].end_date > from && !this._rec_markers[sev[ i ].id] )
								result.push(sev[ i ] );
						}
					}
					else if( !this._is_virtual_event(ev.id) )//if it's virtual event we can skip it;
						result.push( ev );
				}
			}
			return result;
		};

		scheduler.attachEvent("onClearAll", function(){
			scheduler._rec_markers = {};//clear recurring events data
			scheduler._rec_markers_pull = {};
			scheduler._rec_temp = [];
		});


		/*** month view tooltip ***/
		scheduler.templates.month_tooltip = function( s, e, ev )
		{
			var tip = {
				transaction_entity : ev.cd$transaction_entity,
				partner_name : '',
				trade_terms : ev.info.nm$trade_terms,
				delivery_type : ev.info.nm$category_delivery_type,
				addr : ev.info.addr_place_of_delivery.f,
				member : ev.nm$member_public.a
			};
			if( ev.type === "release" ) tip.partner_name = ev.info.nm$partner_buyer;
			else if( ev.type === "departure" ) tip.partner_name = ev.info.nm$partner_buyer;
			else if( ev.type === "wearing" ) tip.partner_name = ev.info.nm$partner_supplier;

			var html = "";
				html += "<table data-event-id='" + ev.id + "'>";
				html += "<col style='width:100px;' /><col style='width:200px;overflow:hidden;' />";
				html += "<tr><td class='sdr_cal_event'>거래 번호</td><td class='sdr_cal_event'>" + ( tip.transaction_entity ) + "</td></tr>";
				html += "<tr><td class='sdr_cal_event'>거래처</td><td class='sdr_cal_event'>" + ( tip.partner_name ) + "</td></tr>";
				html += "<tr><td class='sdr_cal_event'>거래 조건</td><td class='sdr_cal_event'>" + ( tip.trade_terms ) + "</td></tr>";
				html += "<tr><td class='sdr_cal_event'>배송 방법</td><td class='sdr_cal_event'>" + ( tip.delivery_type ) + "</td></tr>";
				html += "<tr><td class='sdr_cal_event'>배송 도시</td><td class='sdr_cal_event'>" + ( tip.addr ) + "</td></tr>";
				html += "<tr><td class='sdr_cal_event'>거래 담당자</td><td class='sdr_cal_event'>" + ( tip.member ) + "</td></tr>";
				html += "</table>";

			return html;
		};

		(function(){
			scheduler._hideMonthToolTip = function()
			{
				if( this._tooltip )
				{
					this._tooltip.style.display = "none";
					this._tooltip.id = "";
				}
			};

			scheduler._showMonthToolTip = function( pos, e, src )
			{
				var id = src.getAttribute("data-event-id") || "";
				if( !id) return;
				var ev = scheduler.getEvent( id );

				if( this._tooltip )
				{
					if( this._tooltip.id === id) return;
					this._tooltip.innerHTML = "";
				}
				else
				{
					var t = this._tooltip = document.createElement( "DIV" );
					t.className = "sdr_month_tooltip";
					document.body.appendChild( t );
					t.style.cssText = "position:absolute;width:300px;background-color:#fff;border:1px solid #666;font-size:9pt;z-index:10000;"
					t.style.width = "300px";
					t.style.position = "absolute";
					t.style.zIndex = "10000";
					t.onclick = scheduler._click.sdr_cal_data;
					//Scheduler.eventObject._attachDomEvent(t, "mouseover", scheduler._click.sdr_cal_data);
				}

				var html = this.templates.month_tooltip(ev.start_date, ev.end_date, ev);

				this._tooltip.style.display = "block";
				this._tooltip.style.top = "0px";

				if( document.body.offsetWidth - pos.left - src.offsetWidth - this._tooltip.offsetWidth < 0 ) this._tooltip.style.left = pos.left - this._tooltip.offsetWidth + "px";
				else this._tooltip.style.left = pos.left + src.offsetWidth + "px";

				this._tooltip.id = id;
				this._tooltip.setAttribute("data-event-id", id);
				this._tooltip.innerHTML = html;

				if( document.body.offsetHeight - pos.top - this._tooltip.offsetHeight < 0 ) this._tooltip.style.top = pos.top - this._tooltip.offsetHeight + src.offsetHeight + "px";
				else this._tooltip.style.top = pos.top + "px";
			};

			scheduler._removeMonthTooltip = function()
			{
				var el = document.getElementsByClassName("sdr_month_tooltip")[ 0 ];
				if( el )
				{
					//Scheduler.eventObject._detachDomEvent(el, "mouseover", scheduler._click.sdr_cal_data);
					el.parentNode.removeChild( el );
				}
				scheduler._tooltip = null;
			};

			scheduler._month_view_tooltip_handler = function( e )
			{
				if( scheduler._mode !== "month" ) return;

				var e = e || event;
				var src = e.target || e.srcElement;
				//fix for active links extension (it adds links to the date in the cell);
				if( src.tagName.toLowerCase() === 'a' ) src = src.parentNode;
				if( (src.className || "").indexOf("sdr_cal_event") !== -1 ) scheduler._showMonthToolTip(Scheduler.util.getOffset(src), e, src);
				else scheduler._hideMonthToolTip();
			};

			scheduler._init_month_tooltip = function()
			{
				Scheduler.eventObject._detachDomEvent(scheduler._els["sdr_cal_data"][ 0 ], "mouseover", scheduler._month_view_tooltip_handler);
				Scheduler.eventObject._attachDomEvent(scheduler._els["sdr_cal_data"][ 0 ], "mouseover", scheduler._month_view_tooltip_handler);
			};
		})();


		/*** year view ***/
		scheduler.templates.year_date = function( date ){ return scheduler.date.date_to_str(scheduler.config.year_date)(date); };
		scheduler.templates.year_month = scheduler.date.date_to_str( "%F" );
		scheduler.templates.year_scale_date = scheduler.date.date_to_str( "%D" );
		scheduler.templates.year_tooltip = function( s, e, ev ){ return ev.text; };

		(function(){
			scheduler.dblclick_sdr_month_head = function( e )
			{
				if( scheduler._mode === "year" )
				{
					var t = ( e.target || e.srcElement );
					if( t.parentNode.className.indexOf( "sdr_before" ) !== -1 || t.parentNode.className.indexOf("sdr_after") !== -1) return false;
					var start = this.templates.xml_date( t.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.getAttribute( "data-date" ) );
						start.setDate( parseInt( t.innerHTML, 10 ) );
					var end = this.date.add( start, 1, "day" );
					if( !this.config.readonly && this.config.dblclick_create ) this.addEventNow( start.valueOf(), end.valueOf(), e );
				}
			};

			//override function;
			var chid = scheduler.changeEventId;
			scheduler.changeEventId = function()
			{
				chid.apply( this, arguments );
				if( scheduler._mode === "year" ) this.year_view( true );
			};

			var old = scheduler.render_data;
			var to_attr = scheduler.date.date_to_str("%Y/%m/%d" );
			var from_attr = scheduler.date.str_to_date("%Y/%m/%d" );
			scheduler.render_data = function( evs )
			{
				if( scheduler._mode !== "year") return old.apply( this, arguments );
				for( var i = 0; i < evs.length; i++ ) this._year_render_event(evs[ i ] );
			};

			//override function;
			var clear = scheduler.clear_view;
			scheduler.clear_view = function()
			{
				if( scheduler._mode !== "year") return clear.apply( this, arguments );
				var dates = scheduler._year_marked_cells, div = null;
				for( var date in dates )
				{
					if( dates.hasOwnProperty(date) )
					{
						div = dates[date];
						div.className = "sdr_month_head";
						div.setAttribute("data-date", "" );
					}
				}
				scheduler._year_marked_cells = {};
			};

			scheduler._hideYearToolTip = function()
			{
				if( this._tooltip )
				{
					this._tooltip.style.display = "none";
					this._tooltip.date = new Date(9999, 0, 1);
				}
			};

			scheduler._showYearToolTip = function( date, pos, e, src )
			{
				if( this._tooltip )
				{
					if( this._tooltip.date.valueOf() === date.valueOf()) return;
					this._tooltip.innerHTML = "";
				}
				else
				{
					var t = this._tooltip = document.createElement( "DIV" );
						t.className = "sdr_year_tooltip";
					document.body.appendChild( t );
					t.onclick = scheduler._click.sdr_cal_data;
				}

				var evs = this.getEvents(date, this.date.add(date, 1, "day"));
				var html = "";

				for( var i = 0; i < evs.length; i++ )
				{
					var ev = evs[ i ];
					if( !this.filter_event(ev.id, ev ) ) continue;

					var bg_color = (ev.color ? ("background:" + ev.color + ";") : "" );
					var color = (ev.textColor ? ("color:" + ev.textColor + ";") : "" );

					html += "<div class='sdr_tooltip_line' style='" + bg_color + "" + color + "' data-event-id='" + evs[ i ].id + "'>";
					html += "<div class='sdr_tooltip_date' style='" + bg_color + "" + color + "'>" + (evs[ i ]._timed ? this.templates.event_date(evs[ i ].start_date) : "") + "</div>";
					html += "<div class='sdr_event_icon icon_details'>&nbsp;</div>";
					html += this.templates.year_tooltip(evs[ i ].start_date, evs[ i ].end_date, evs[ i ]) + "</div>";
				}

				this._tooltip.style.display = "";
				this._tooltip.style.top = "0px";

				if( document.body.offsetWidth - pos.left - this._tooltip.offsetWidth < 0 ) this._tooltip.style.left = pos.left - this._tooltip.offsetWidth + "px";
				else this._tooltip.style.left = pos.left + src.offsetWidth + "px";

				this._tooltip.date = date;
				this._tooltip.innerHTML = html;

				if( document.body.offsetHeight - pos.top - this._tooltip.offsetHeight < 0)
					this._tooltip.style.top = pos.top - this._tooltip.offsetHeight + src.offsetHeight + "px";
				else
					this._tooltip.style.top = pos.top + "px";
			};

			scheduler._removeYearTooltip = function()
			{
				var el = document.getElementsByClassName("sdr_year_tooltip")[ 0 ];
				if( el ) el.parentNode.removeChild( el );
				scheduler._tooltip = null;
			};

			scheduler._year_view_tooltip_handler = function( e )
			{
				if( scheduler._mode !== "year") return;

				var e = e || event;
				var src = e.target || e.srcElement;
				//fix for active links extension (it adds links to the date in the cell);
				if( src.tagName.toLowerCase() === 'a') src = src.parentNode;

				if( (src.className || "").indexOf("sdr_year_event") !== -1 ) scheduler._showYearToolTip(from_attr(src.getAttribute("data-date")), Scheduler.util.getOffset(src), e, src);
				else scheduler._hideYearToolTip();
			};

			scheduler._init_year_tooltip = function()
			{
				Scheduler.eventObject._detachDomEvent(scheduler._els["sdr_cal_data"][ 0 ], "mouseover", scheduler._year_view_tooltip_handler);
				Scheduler.eventObject._attachDomEvent(scheduler._els["sdr_cal_data"][ 0 ], "mouseover", scheduler._year_view_tooltip_handler);
			};

			scheduler.attachEvent("onSchedulerResize", function(){
				if( scheduler._mode === "year" )
				{
					this.year_view( true );
					return false;
				}
				return true;
			});

			scheduler._get_year_cell = function( d )
			{
				//year can start not from January;
				var m = d.getMonth() + 12 * (d.getFullYear() - this._min_date.getFullYear()) - this.week_starts._month;
				var t = this._els["sdr_cal_data"][ 0 ].childNodes[ m ];
				var d = this.week_starts[ m ] + d.getDate() - 1;

				return t.childNodes[ 2 ].firstChild.rows[Math.floor(d / 7)].cells[d % 7].firstChild;
			};

			scheduler._year_marked_cells = {};

			scheduler._mark_year_date = function( d, ev )
			{
				var date = to_attr( d );
				var c = this._get_year_cell( d );
				var ev_class = this.templates.event_class(ev.start_date, ev.end_date, ev);
				if( !scheduler._year_marked_cells[date] )
				{
					c.className = "sdr_month_head sdr_year_event";
					c.setAttribute("data-date", date);
					scheduler._year_marked_cells[date] = c;
				}
				c.className += (ev_class) ? (" " + ev_class) : "";
			};
			scheduler._unmark_year_date = function( d ){ this._get_year_cell( d ).className = "sdr_month_head"; };
			scheduler._year_render_event = function( ev )
			{
				var d = ev.start_date;
				if( d.valueOf() < this._min_date.valueOf()) d = this._min_date;
				else d = this.date.date_part(new Date( d ));

				while( d < ev.end_date )
				{
					this._mark_year_date(d, ev);
					d = this.date.add(d, 1, "day" );
					if( d.valueOf() >= this._max_date.valueOf()) return;
				}
			};

			scheduler.year_view = function( mode )
			{
				var temp;
				if( mode )
				{
					temp = scheduler.xy.scale_height;
					scheduler.xy.scale_height = -1;
				}

				scheduler._els["sdr_cal_header"][ 0 ].style.display = mode ? "none" : "";
				scheduler.set_sizes();

				if( mode ) scheduler.xy.scale_height = temp;

				scheduler._table_view = mode;
				if( this._load_mode && this._load()) return;

				if( mode )
				{
					scheduler._init_year_tooltip();
					scheduler._reset_year_scale();
					if( scheduler._load_mode && scheduler._load() )
					{
						scheduler._render_wait = true;
						return;
					}
					scheduler.render_view_data();
				}
				else scheduler._hideYearToolTip();
			};

			scheduler._reset_year_scale = function()
			{
				this._cols = [];
				this._colsS = {};
				var week_starts = [];//start day of first week in each month;
				var b = this._els["sdr_cal_data"][ 0 ];

				var config = this.config;
				b.scrollTop = 0;//fix flickering in FF;
				b.innerHTML = "";

				var dx = Math.floor( parseInt( b.style.width ) / config.year_x );
				var dy = Math.floor( ( parseInt( b.style.height ) - scheduler.xy.year_top) / config.year_y );
				if( dy < 190 )
				{
					dy = 190;
					dx = Math.floor((parseInt( b.style.width ) - scheduler.xy.scroll_width) / config.year_x );
				}

				var summ = dx - 11;
				var left = 0;
				var week_template = document.createElement( "DIV" );
				var dummy_date = this.date.week_start(scheduler._currentDate() );
				for( var i = 0; i < 7; i++ )
				{
					this._cols[ i ] = Math.floor(summ / (7 - i));
					this._render_x_header(i, left, dummy_date, week_template);
					dummy_date = this.date.add(dummy_date, 1, "day" );
					summ -= this._cols[ i ];
					left += this._cols[ i ];
				}
				week_template.lastChild.className += " sdr_scale_bar_last";

				var sd = this.date[this._mode + "_start"](this.date.copy( this._date ));
				var ssd = sd;
				var d = null;
				for( var i = 0; i < config.year_y; i++ )
				{
					for( var j = 0; j < config.year_x; j++ )
					{
						d = document.createElement( "DIV" );
						d.style.cssText = "position:absolute;";
						d.setAttribute( "data-date", this.templates.xml_format( sd ) );
						d.innerHTML = "<div class='sdr_year_month'></div><div class='sdr_year_week'>" + week_template.innerHTML + "</div><div class='sdr_year_body'></div>";
						d.childNodes[ 0 ].innerHTML = this.templates.year_month( sd );

						var dd = this.date.week_start( sd );
						var ed = this._reset_month_scale(d.childNodes[ 2 ], sd, dd);

						var r = d.childNodes[ 2 ].firstChild.rows;
						for( var k = r.length; k < 6; k++ )
						{
							r[ 0 ].parentNode.appendChild(r[ 0 ].cloneNode( true ));
							for( var ri = 0, len = r[ k ].childNodes.length; ri < len; ri++ )
							{
								r[ k ].childNodes[ ri ].className = "sdr_after";
								r[ k ].childNodes[ ri ].firstChild.innerHTML = scheduler.templates.month_day( ed );
								ed = scheduler.date.add(ed, 1, "day" );
							}
						}
						b.appendChild( d );

						//sdr_year_week should have height property so that day dates would get correct position. sdr_year_week height = height of it's child (with the day name);
						d.childNodes[ 1 ].style.height = d.childNodes[ 1 ].childNodes[ 0 ].offsetHeight + "px";

						var dt = Math.round((dy - 190) / 2);
						d.style.marginTop = dt + "px";
						this.set_xy(d, dx - 10, dy - dt - 10, dx * j + 5, dy * i + 5 + scheduler.xy.year_top);

						week_starts[i * config.year_x + j] = (sd.getDay() - (this.config.start_on_monday ? 1 : 0) + 7) % 7;
						sd = this.date.add(sd, 1, "month" );
					}
				}

				this._els["sdr_cal_date"][ 0 ].innerHTML = this.templates[this._mode + "_date"](ssd, sd, this._mode);
				this.week_starts = week_starts;
				week_starts._month = ssd.getMonth();
				this._min_date = ssd;
				this._max_date = sd;
			};

			//override function
			var getActionData = scheduler.getActionData;
			scheduler.getActionData = function( n_ev )
			{
				if( scheduler._mode !== "year") return getActionData.apply(scheduler, arguments);

				var trg = n_ev ? n_ev.target : event.srcElement;
				var date = scheduler._get_year_month_date( trg );

				var day = scheduler._get_year_month_cell( trg );
				var pos = scheduler._get_year_day_indexes( day );

				if( pos && date )
				{
					date = scheduler.date.add(date, pos.week, "week" );
					date = scheduler.date.add(date, pos.day, "day" );
				}
				else date = null;

				return { date : date, section : null };
			};

			scheduler._get_year_day_indexes = function( targetCell )
			{
				var month = scheduler._get_year_el_node(targetCell, this._locate_year_month_table);
				if( !month ) return null;

				var week = 0, day = 0;
				for( var week = 0, weeks = month.rows.length; week < weeks; week++ )
				{
					var w = month.rows[week].getElementsByTagName("td" );
					for( var day = 0, days = w.length; day < days; day++ )
						if( w[ day ] === targetCell ) break;

					if( day < days ) break;
				}

				if( week < weeks ) return { day : day, week : week };
				else return null;
			};

			scheduler._get_year_month_date = function( node )
			{
				node = scheduler._get_year_el_node(node, scheduler._locate_year_month_root);
				if( !node ) return null;
				var date = node.getAttribute("data-date" );
				if( !date ) return null;
				return scheduler.date.week_start(scheduler.templates.xml_date(date));
			};

			scheduler._locate_year_month_day = function( n ){ return n.className && n.className.indexOf("sdr_year_event") !== -1 && n.hasAttribute && n.hasAttribute( "date" ); };

			//override function
			var locateEvent = scheduler._locate_event;
			scheduler._locate_event = function( node )
			{
				var id = locateEvent.apply(scheduler, arguments);
				if( !id )
				{
					var day = scheduler._get_year_el_node(node, scheduler._locate_year_month_day);

					if( !day || !day.hasAttribute( "date" )) return null;

					var dat = scheduler.templates.xml_date(day.getAttribute("data-date"));
					var evs = scheduler.getEvents(dat, scheduler.date.add(dat, 1, "day"));
					if( !evs.length) return null;

					//can be multiple events in the cell, return any single one;
					id = evs[ 0 ].id;
				}
				return id;
			};

			scheduler._locate_year_month_cell = function( n ){ return n.nodeName.toLowerCase() === "td"; };
			scheduler._locate_year_month_table = function( n ){ return n.nodeName.toLowerCase() === "table"; };
			scheduler._locate_year_month_root = function( n ){ return n.hasAttribute && n.hasAttribute( "date" ); };

			scheduler._get_year_month_cell = function( node ){ return this._get_year_el_node(node, this._locate_year_month_cell); };
			scheduler._get_year_month_table = function( node ){ return this._get_year_el_node(node, this._locate_year_month_table); };
			scheduler._get_year_month_root = function( node ){ return this._get_year_el_node(this._get_year_month_table( node ), this._locate_year_month_root); };
			scheduler._get_year_el_node = function( node, condition )
			{
				while( node && !condition( node ) ) node = node.parentNode;
				return node;
			};
		})();

		/*** list view ***/
		scheduler.templates.list_time = function( start, end, ev )
		{
			if( ev._timed ) return this.day_date(ev.start_date, ev.end_date, ev) + " " + this.event_date( start );
			else return scheduler.templates.day_date( start ) + " ~ " + scheduler.templates.day_date( end );
		};
		scheduler.templates.list_text = function( start, end, event ){ return event.text; };
		scheduler.templates.list_date = function(){ return ""; };

		scheduler.attachEvent("onTemplatesReady", function(){
			//override function;
			var old_dblclick_sdr_cal_data = scheduler.dblclick_sdr_cal_data;
			scheduler.dblclick_sdr_cal_data = function(){
				if( this._mode === "list" )
				{
					if( !this.config.readonly && this.config.dblclick_create )
						this.addEventNow();
				}
				else
				{
					if( old_dblclick_sdr_cal_data ) return old_dblclick_sdr_cal_data.apply( this, arguments );
				}
			};

			scheduler.attachEvent( "onSchedulerResize", function(){
				if( this._mode === "list" )
				{
					this.list_view( true );
					return false;
				}
				return true;
			});

			//override function;
			var old = scheduler.render_data;
			scheduler.render_data = function( evs )
			{
				if( this._mode === "list") fill_list_tab();
				else return old.apply( this, arguments );
			};

			//override function;
			var old_render_view_data = scheduler.render_view_data;
			scheduler.render_view_data = function()
			{
				if( this._mode === "list" )
				{
					scheduler._listScrollTop = scheduler._els["sdr_cal_data"][ 0 ].childNodes[ 0 ].scrollTop;
					scheduler._els["sdr_cal_data"][ 0 ].childNodes[ 0 ].scrollTop = 0;
				}
				return old_render_view_data.apply( this, arguments );
			};

			function set_full_view( mode )
			{
				if( mode )
				{
					var l = scheduler.locale.labels;
					scheduler._els["sdr_cal_header"][ 0 ].innerHTML = "<div class='sdr_list_line'><div>" + l.date + "</div><span style='padding-left:25px'>" + l.description + "</span></div>";
					scheduler._table_view = true;
					scheduler.set_sizes();
				}
			}

			function fill_list_tab()
			{
				//get current date
				//var date = scheduler._date;

				var events = scheduler.get_visible_events();
				events.sort(function( a, b ){ return a.start_date > b.start_date ? 1 : -1; });

				//generate html for the view;
				var html = "<div class='sdr_list_area'>";
				for( var i = 0; i < events.length; i++ )
				{
					var ev = events[ i ];
					var bg_color = (ev.color ? ("background:" + ev.color + ";") : "" );
					var color = (ev.textColor ? ("color:" + ev.textColor + ";") : "" );
					var ev_class = scheduler.templates.event_class(ev.start_date, ev.end_date, ev);
					html += "<div class='sdr_list_line" + (ev_class ? ' ' + ev_class : '') + "' data-event-id='" + ev.id + "' style='" + color + "" + bg_color + "" + (ev._text_style || "") + "'><div class='sdr_list_event_time'>" + scheduler.templates.list_time(ev.start_date, ev.end_date, ev) + "</div>";
					html += "<div class='sdr_event_icon icon_details'>&nbsp;</div>";
					html += "<span>" + scheduler.templates.list_text(ev.start_date, ev.end_date, ev) + "</span></div>";
				}
				html += "<div class='sdr_v_border'></div></div>";

				//render html;
				scheduler._els["sdr_cal_data"][ 0 ].innerHTML = html;
				scheduler._els["sdr_cal_data"][ 0 ].childNodes[ 0 ].scrollTop = scheduler._listScrollTop || 0;

				//setting up sdr_v_border size;
				var list_area = scheduler._els["sdr_cal_data"][ 0 ].childNodes[ 0 ];
				var v_border = list_area.childNodes[list_area.childNodes.length - 1];
				v_border.style.height = (list_area.offsetHeight < scheduler._els["sdr_cal_data"][ 0 ].offsetHeight) ? "100%" : (list_area.offsetHeight + "px" );

				var t = scheduler._els["sdr_cal_data"][ 0 ].firstChild.childNodes;
				scheduler._els["sdr_cal_date"][ 0 ].innerHTML = scheduler.templates.list_date(scheduler._min_date, scheduler._max_date, scheduler._mode);

				scheduler._rendered = [];
				for( var i = 0; i < t.length - 1; i++ ) scheduler._rendered[ i ] = t[ i ];
			}

			scheduler.list_view = function( mode )
			{
				scheduler._min_date = scheduler.config.list_start || scheduler.date.list_start(scheduler._date);
				scheduler._max_date = scheduler.config.list_end || scheduler.date.add_list(scheduler._min_date, 1);
				scheduler._table_view = true;
				set_full_view(mode);
				if( mode )
				{
					//list tab activated;
					fill_list_tab();
				}
				else
				{
					//list tab de-activated;
				}
			};
		});

		/**
		 * call modal page
		 * @param id
		 * @public
		 */
		scheduler.showModalPage = function( id ){
			//custom override function
			window.JaceLog.log('function showModalPage id = ' + id);
		};

		return scheduler._internal_id = Scheduler._seed++, scheduler;
	};


	Scheduler.util = Scheduler.eventObject = Scheduler.component = {};

	/**
	 * Scheduler.util.ajax
	 * @private
	 * @type {{get : get, post : post}}
	 */
	Scheduler.util.ajax = {
		get : function( url, callback ){
			var t = new Scheduler.xmlLoaderObject( true );
			t.async = true;
			t.waitCall = callback;
			t.loadXML(url);
			return t;
		},
		post : function( url, post, callback ){
			var t = new Scheduler.xmlLoaderObject( true );
			t.async = true;
			t.waitCall = callback;
			t.loadXML(url, true, post);
			return t;
		}
	};

	/**
	 * Scheduler.xmlLoaderObject
	 * @private
	 * @param : funcObject - xml parser function
	 * @param : object - jsControl object
	 * @param : async - sync/async mode (async by default)
	 * @param : rSeed - enable/disable random seed (prevent IE caching)
	 */
	Scheduler.xmlLoaderObject = function( funcObject, htmlObject, async, rSeed )
	{
		this.xmlDoc = "";
		this.async = (typeof (async) !== "undefined") ? async : true;
		this.onloadAction = funcObject || null;
		this.mainObject = htmlObject || null;
		this.waitCall = null;
		this.rSeed = rSeed || false;
		return this;
	};

	Scheduler.xmlLoaderObject.count = 0;

	/**
	 * xml loading handler
	 * @private
	 * @param : xmlLoader object
	 */
	Scheduler.xmlLoaderObject.prototype.waitLoadFunction = function( xmlObject )
	{
		var once = true;
		this.check = function()
		{
			if( (xmlObject) && (xmlObject.onloadAction) )
			{
				if( (!xmlObject.xmlDoc.readyState) || (xmlObject.xmlDoc.readyState === 4) )
				{
					if( !once ) return;
					once = false;//IE 5 fix;
					Scheduler.xmlLoaderObject.count++;
					if( typeof xmlObject.onloadAction === "function" ) xmlObject.onloadAction(xmlObject.mainObject, null, null, null, xmlObject);
					if( xmlObject.waitCall )
					{
						xmlObject.waitCall.call(this, xmlObject);
						xmlObject.waitCall = null;
					}
				}
			}
		};
		return this.check;
	};

	/**
	 * return XML top node
	 * @private
	 * @param : tagName - top XML node tag name (not used in IE, required for Safari and Mozilla)
	 * @returns : top XML node
	 */
	Scheduler.xmlLoaderObject.prototype.getXMLTopNode = function( tagName, oldObj )
	{
		var z;

		if( this.xmlDoc.responseXML )
		{
			var temp = this.xmlDoc.responseXML.getElementsByTagName(tagName);
			if( temp.length === 0 && tagName.indexOf(":") !== -1 ) temp = this.xmlDoc.responseXML.getElementsByTagName((tagName.split(":"))[ 1 ] );
			z = temp[ 0 ];
		}
		else z = this.xmlDoc.documentElement;

		if( z )
		{
			this._retry = false;
			return z;
		}

		if( !this._retry && _isIE )
		{
			this._retry = true;
			oldObj = this.xmlDoc;
			this.loadXMLString(this.xmlDoc.responseText.replace(/^[\s]+/, ""), true);
			return this.getXMLTopNode(tagName, oldObj);
		}

		Scheduler.componentError.throwError("LoadXML", "Incorrect XML", [ (oldObj || this.xmlDoc), this.mainObject ] );

		return document.createElement( "DIV" );
	};

	/**
	 * load XML from string
	 * @private
	 * @param : xml string
	 * @param : silent
	 */
	Scheduler.xmlLoaderObject.prototype.loadXMLString = function( xmlString, silent )
	{
		if( !_isIE )
		{
			var parser = new DOMParser();
			this.xmlDoc = parser.parseFromString(xmlString, "text/xml" );
		}
		else
		{
			this.xmlDoc = new ActiveXObject("Microsoft.XMLDOM" );
			this.xmlDoc.async = this.async;
			this.xmlDoc.onreadystatechange = function(){};
			this.xmlDoc["loadXM" + "L"]( xmlString );
		}

		if( silent ) return;

		if( this.onloadAction ) this.onloadAction(this.mainObject, null, null, null, this);

		if( this.waitCall )
		{
			this.waitCall();
			this.waitCall = null;
		}
	};

	/**
	 * load XML
	 * @private
	 * @param : filePath - xml file path
	 * @param : postMode - send POST request
	 * @param : postVars - list of vars for post request
	 */
	Scheduler.xmlLoaderObject.prototype.loadXML = function( filePath, postMode, postVars )
	{
		if( this.rSeed ) filePath += ((filePath.indexOf("?") !== -1) ? "&" : "?") + "a_sdr_rSeed=" + ( new Date() ).valueOf();
		this.filePath = filePath;

		if( (!_isIE ) && (window.XMLHttpRequest) ) this.xmlDoc = new XMLHttpRequest();
		else this.xmlDoc = new ActiveXObject("Microsoft.XMLHTTP" );

		if( this.async ) this.xmlDoc.onreadystatechange = new this.waitLoadFunction( this );

		if( typeof postMode === "string" ) this.xmlDoc.open(postMode, filePath, this.async);
		else this.xmlDoc.open(postMode ? "POST" : "GET", filePath, this.async);

		if( postMode ) this.xmlDoc.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');

		this.xmlDoc.setRequestHeader("X-Requested-With", "XMLHttpRequest" );
		this.xmlDoc.send(null || postVars);

		if( !this.async ) (new this.waitLoadFunction( this ))();
	};

	/**
	 * destructor, cleans used memory
	 * @private
	 */
	Scheduler.xmlLoaderObject.prototype.destructor = function(){
		this._filterXPath = null;
		this._getAllNamedChilds = null;
		this._retry = null;
		this.async = null;
		this.rSeed = null;
		this.onloadAction = null;
		this.mainObject = null;
		this.xmlDoc = null;
		this.doXPath = null;
		this.doXPathOpera = null;
		this.loadXML = null;
		this.loadXMLString = null;
		this.xmlNodeToJSON = null;
		this.getXMLTopNode = null;
		//this.waitLoadFunction = null;
		return null;
	};

	Scheduler.xmlLoaderObject.prototype.xmlNodeToJSON = function( node )
	{
		var t = {};
		for( var i = 0; i < node.attributes.length; i++ )
			t[node.attributes[ i ].name] = node.attributes[ i ].value;

		t["_tagvalue"] = node.firstChild ? node.firstChild.nodeValue : "";
		for( var i = 0; i < node.childNodes.length; i++ )
		{
			var name = node.childNodes[ i ].tagName;
			if( name )
			{
				if( !t[ name ]) t[ name ] = [];
				t[ name ].push(this.xmlNodeToJSON(node.childNodes[ i ]));
			}
		}
		return t;
	};


	Scheduler.util.getAbsoluteLeft = function( htmlObject ){ return Scheduler.util.getOffset(htmlObject).left; };
	Scheduler.util.getAbsoluteTop = function( htmlObject ){ return Scheduler.util.getOffset(htmlObject).top; };
	Scheduler.util.getOffsetSum = function( elem )
	{
		var top = 0, left = 0;
		while( elem )
		{
			top = top + parseInt(elem.offsetTop);
			left = left + parseInt(elem.offsetLeft);
			elem = elem.offsetParent;
		}
		return { top : top, left : left };
	};

	Scheduler.util.getOffsetRect = function( elem )
	{
		var box = elem.getBoundingClientRect();
		var body = document.body;
		var docElem = document.documentElement;
		var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
		var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
		var clientTop = docElem.clientTop || body.clientTop || 0;
		var clientLeft = docElem.clientLeft || body.clientLeft || 0;
		var top = box.top + scrollTop - clientTop;
		var left = box.left + scrollLeft - clientLeft;
		return { top : Math.round( top ), left : Math.round( left ) };
	};

	Scheduler.util.getOffset = function( elem ){ return (elem.getBoundingClientRect) ? Scheduler.util.getOffsetRect( elem ) : Scheduler.util.getOffsetSum( elem ); };

	Scheduler.util.getUrlSymbol = function( str ){ return (str.indexOf("?") !== -1) ? "&" : "?"; };


	//check browser;
	var _isFF = false;
	var _isIE = false;
	var _isOpera = false;
	var _isKHTML = false;
	var _isMacOS = false;
	var _isChrome = false;
	var _FFrv = false;
	var _KHTMLrv = false;
	var _OperaRv = false;

	if( navigator.userAgent.indexOf('Macintosh') !== -1 ) _isMacOS = true;
	if( navigator.userAgent.toLowerCase().indexOf('chrome') > -1 ) _isChrome = true;
	if( (navigator.userAgent.indexOf('Safari') !== -1) || (navigator.userAgent.indexOf('Konqueror') !== -1) )
	{
		_KHTMLrv = parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Safari') + 7, 5));
		if( _KHTMLrv > 525 )//mimic FF behavior for Safari 3.1+;
		{
			_isFF = true;
			_FFrv = 1.9;
		}
		else _isKHTML = true;
	}
	else if( navigator.userAgent.indexOf('Opera') !== -1 )
	{
		_isOpera = true;
		_OperaRv = parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Opera') + 6, 3));
	}
	else if( navigator.appName.indexOf("Microsoft") !== -1 )
	{
		_isIE = true;
		if( (navigator.appVersion.indexOf("MSIE 8.0") !== -1 || navigator.appVersion.indexOf("MSIE 9.0") !== -1 || navigator.appVersion.indexOf("MSIE 10.0") !== -1 ) && document.compatMode !== "BackCompat" )
			_isIE = 8;
	}
	else if( navigator.appName === 'Netscape' && navigator.userAgent.indexOf("Trident") !== -1 )
	{
		//ie11;
		_isIE = 8;
	}
	else
	{
		_isFF = true;
		_FFrv = parseFloat(navigator.userAgent.split("rv:")[ 1 ] );
	}

	//multibrowser Xpath processor;
	Scheduler.xmlLoaderObject.prototype.doXPath = function( xpathExp, docObj, namespace, result_type )
	{
		if( _isKHTML || ( !_isIE && !window.XPathResult ) ) return this.doXPathOpera( xpathExp, docObj );

		if( _isIE )//IE;
		{
			if( !docObj )
			{
				if( !this.xmlDoc.nodeName ) docObj = this.xmlDoc.responseXML;
				else docObj = this.xmlDoc;
			}
			if( !docObj ) Scheduler.componentError.throwError("LoadXML", "Incorrect XML", [ (docObj || this.xmlDoc), this.mainObject ] );
			if( namespace ) docObj.setProperty("SelectionNamespaces", "xmlns:xsl='" + namespace + "'" );
			if( result_type === 'single' ) return docObj.selectSingleNode( xpathExp );
			else return docObj.selectNodes( xpathExp ) || new Array( 0 );
		}
		else//Mozilla;
		{
			var nodeObj = docObj;

			if( !docObj )
			{
				if( !this.xmlDoc.nodeName ) docObj = this.xmlDoc.responseXML;
				else docObj = this.xmlDoc;
			}

			if( !docObj) Scheduler.componentError.throwError("LoadXML", "Incorrect XML", [ (docObj || this.xmlDoc), this.mainObject ] );

			if( docObj.nodeName.indexOf("document") !== -1 ) nodeObj = docObj;
			else
			{
				nodeObj = docObj;
				docObj = docObj.ownerDocument;
			}
			var retType = XPathResult.ANY_TYPE;

			if( result_type === 'single' ) retType = XPathResult.FIRST_ORDERED_NODE_TYPE;
			var rowsCol = [];
			var col = docObj.evaluate(xpathExp, nodeObj, function( pref ){ return namespace; }, retType, null );

			if( retType === XPathResult.FIRST_ORDERED_NODE_TYPE ) return col.singleNodeValue;

			var thisColMemb = col.iterateNext();

			while( thisColMemb )
			{
				rowsCol[rowsCol.length] = thisColMemb;
				thisColMemb = col.iterateNext();
			}
			return rowsCol;
		}
	};

	//opera fake, while 9.0 not released
	//multibrowser Xpath processor
	Scheduler.xmlLoaderObject.prototype.doXPathOpera = function( xpathExp, docObj )
	{
		//this is fake for Opera;
		var z = xpathExp.replace(/[\/]+/gi, "/").split('/');
		var obj = null;
		var i = 1;

		if( !z.length ) return [];

		if( z[ 0 ] === "." ) obj = [ docObj ];
		else if( z[ 0 ] === "" )
		{
			obj = (this.xmlDoc.responseXML || this.xmlDoc).getElementsByTagName(z[ i ].replace(/\[[^\]]*\]/g, ""));
			i++;
		}
		else return [];

		for( i; i < z.length; i++ )obj = this._getAllNamedChilds(obj, z[ i ] );

		if( z[i - 1].indexOf("[") !== -1 ) obj = this._filterXPath(obj, z[i - 1] );
		return obj;
	};

	Scheduler.xmlLoaderObject.prototype._filterXPath = function( a, b )
	{
		var c = [];
		var b = b.replace(/[^\[]*\[\@/g, "").replace(/[\[\]\@]*/g, "" );

		for( var i = 0; i < a.length; i++ ) if( a[ i ].getAttribute( b )) c[ c.length ] = a[ i ];

		return c;
	};

	Scheduler.xmlLoaderObject.prototype._getAllNamedChilds = function( a, b )
	{
		var c = [];

		if( _isKHTML) b = b.toUpperCase();

		for( var i = 0; i < a.length; i++ )for( var j = 0; j < a[ i ].childNodes.length; j++ )
		{
			if( _isKHTML )
			{
				if( a[ i ].childNodes[ j ].tagName && a[ i ].childNodes[ j ].tagName.toUpperCase() === b )
					c[c.length] = a[ i ].childNodes[ j ];
			}
			else if( a[ i ].childNodes[ j ].tagName === b ) c[c.length] = a[ i ].childNodes[ j ];
		}

		return c;
	};

	/**
	 * Event Wrapper
	 * @param el
	 * @param event
	 * @param handler
	 * @private
	 */
	Scheduler.eventObject._attachDomEvent = function( el, event, handler )
	{
		if( el.addEventListener ) el.addEventListener( event, handler, false );
		else if( el.attachEvent ) el.attachEvent("on" + event, handler);
	};
	Scheduler.eventObject._detachDomEvent = function( el, event, handler )
	{
		if( el.removeEventListener ) el.removeEventListener( event, handler, false );
		else if( el.detachEvent ) el.detachEvent("on" + event, handler);
	};

	/**
	 * _schedulerComponentError
	 * @returns {_schedulerComponentError}
	 * @private
	 */
	function _schedulerComponentError()
	{
		if( !this.catches ) this.catches = [];
		return this;
	}

	_schedulerComponentError.prototype.catchError = function( type, func_name ){ this.catches[ type ] = func_name; };

	_schedulerComponentError.prototype.throwError = function( type, name, params )
	{
		if( this.catches[ type ]) return this.catches[ type ]( type, name, params );
		if( this.catches[ "ALL" ]) return this.catches[ "ALL" ]( type, name, params );

		alert("Error type : " + arguments[ 0 ] + "\nDescription : " + arguments[ 1 ] );
		return null;
	};

	Scheduler.componentError = new _schedulerComponentError();

	/**
	 * Scheduler.componentEventable
	 * @param obj
	 * @private
	 */
	Scheduler.componentEventable = function( obj )
	{
		obj.attachEvent = function( name, catcher, callObj )
		{
			name = 'ev_' + name.toLowerCase();
			if( !this[ name ] ) this[ name ] = new this.eventCatcher( callObj || this );

			return ( name + ':' + this[ name ].addEvent( catcher ) );//return ID (event name & event ID);
		};
		obj.callEvent = function( name, arg0 )
		{
			name = 'ev_' + name.toLowerCase();
			if( this[ name ] ) return this[ name ].apply(this, arg0);
			return true;
		};
		obj.checkEvent = function( name ){ return (!!this['ev_' + name.toLowerCase()] ); };
		obj.eventCatcher = function( obj )
		{
			var sdr_catch = [];
			var z = function()
			{
				var res = true;
				for( var i = 0; i < sdr_catch.length; i++ )
				{
					if( sdr_catch[ i ] )
					{
						var zr = sdr_catch[ i ].apply( obj, arguments );
						res = res && zr;
					}
				}
				return res;
			};
			z.addEvent = function( ev )
			{
				if( typeof ( ev ) !== "function" ) ev = eval( ev );
				if( ev ) return sdr_catch.push( ev ) - 1;
				return false;
			};
			z.removeEvent = function( id ){ sdr_catch[ id ] = null; };
			return z;
		};
		obj.detachEvent = function( id )
		{
			if( id )
			{
				var list = id.split( ':' );//get EventName and ID;
				this[list[ 0 ]].removeEvent(list[ 1 ] );//remove event;
			}
		};
		obj.detachAllEvents = function()
		{
			for( var name in this )
			{
				if( name.indexOf( "ev_" ) === 0 )
				{
					this.detachEvent( name );
					this[ name ] = null;
				}
			}
		};
		obj = null;
	};


	/*** message box (modal, alert, confirm) ***/
	(function(){
		var _sdr_msg_cfg = null;

		function callback( config, result )
		{
			var usercall = config.callback;
			modality( false );
			config.box.parentNode.removeChild( config.box );
			_sdr_msg_cfg = config.box = null;
			if( usercall) usercall( result );
		}

		function modal_key( e )
		{
			if( _sdr_msg_cfg )
			{
				e = e || event;
				var code = e.which || event.keyCode;
				if( Scheduler.component.message.keyboard )
				{
					//ENTER || SPACE;
					if( code === 13 || code === 32 ) callback( _sdr_msg_cfg, true );
					//ESC;
					if( code === 27 ) callback( _sdr_msg_cfg, false );
				}
				if( e.preventDefault ) e.preventDefault();
				return !( e.cancelBubble = true );
			}
		}

		Scheduler.eventObject._attachDomEvent( document, "keydown", modal_key );

		function modality( mode )
		{
			if( !modality.cover )
			{
				modality.cover = document.createElement( "DIV" );
				//necessary for IE only
				modality.cover.onkeydown = modal_key;
				modality.cover.className = "sdr_modal_cover";
				document.body.appendChild(modality.cover);
			}

			if( mode ) modality.cover.style.display = "inline-block";
			else
			{
				modality.cover.style.display = "none";
				document.body.removeChild(modality.cover);
				modality.cover = null;
			}
		}

		function button(text, result, css )
		{
			//css - for locale-independent class name;
			var className = css ? css : (text || "" );
			var button_css = "sdr_" + (className).toLowerCase().replace(/ /g, "_") + "_button";//sdr_ok_button, sdr_click_me_button
			return "<div class='sdr_popup_button " + button_css + "' result='" + result + "' ><div>" + text + "</div></div>";
		}

		function info( text )
		{
			if( !t.area )
			{
				t.area = document.createElement( "DIV" );
				t.area.className = "sdr_message_area";
				t.area.style[t.position] = "5px";
				document.body.appendChild( t.area );
			}

			t.hide( text.id );
			var message = document.createElement( "DIV" );
			message.innerHTML = "<div>" + text.text + "</div>";
			message.className = "sdr-info sdr-" + text.type;
			message.onclick = function()
			{
				t.hide( text.id );
				text = null;
			};

			if( t.position === "bottom" && t.area.firstChild ) t.area.insertBefore( message, t.area.firstChild );
			else t.area.appendChild( message );

			if( text.expire > 0)
				t.timers[ text.id ] = setTimeout(function(){ t.hide( text.id ); }, text.expire);

			t.pull[ text.id ] = message;
			message = null;

			return text.id;
		}

		function _boxStructure( config, ok, cancel )
		{
			var box = document.createElement( "DIV" );
				box.className = "sdr_modal_box sdr-" + config.type;
				box.setAttribute("sdrbox", 1);

			var inner = '';

			if( config.width ) box.style.width = config.width;
			if( config.height ) box.style.height = config.height;
			if( config.title ) inner += '<div class="sdr_popup_title">' + config.title + '</div>';

			inner += '<div class="sdr_popup_text"><span>' + ( config.content ? '' : config.text) + '</span></div><div class="sdr_popup_controls">';

			if( ok )
			{
				var ok_text = ( config.ok || scheduler.locale.labels.message_ok );

				//default value for compatibility with custom locales some people have;
				if( ok_text === undefined ) ok_text = "OK";
				inner += button( ok_text, true, "ok" );
			}

			if( cancel )
			{
				var cancel_text = ( config.cancel || scheduler.locale.labels.message_cancel );
				if( cancel_text === undefined) cancel_text = "Cancel";
				inner += button(cancel_text, false, "cancel" );
			}

			if( config.buttons )
				for( var i = 0; i < config.buttons.length; i++ )
					inner += button( config.buttons[ i ], i );

			inner += '</div>';
			box.innerHTML = inner;

			if( config.content )
			{
				var node = config.content;
				if( typeof node === "string" ) node = document.getElementById( node );
				if( node.style.display === 'none') node.style.display = "";
				box.childNodes[config.title ? 1 : 0].appendChild( node );
			}

			box.onclick = function( e )
			{
				e = e || event;
				var source = e.target || e.srcElement;
				if( !source.className) source = source.parentNode;
				if( source.className.split( " " )[ 0 ] === "sdr_popup_button" )
				{
					var result = source.getAttribute( "result" );
					result = ( result === "true" ) || (result === "false" ? false : result);
					callback( config, result );
				}
			};
			config.box = box;
			if( ok || cancel ) _sdr_msg_cfg = config;

			return box;
		}

		function _createBox( config, ok, cancel )
		{
			var box = config.tagName ? config : _boxStructure( config, ok, cancel);

			if( !config.hidden ) modality( true );
			document.body.appendChild( box );

			var x = Math.abs(Math.floor(((window.innerWidth || document.documentElement.offsetWidth) - box.offsetWidth) / 2));
			var y = Math.abs(Math.floor(((window.innerHeight || document.documentElement.offsetHeight) - box.offsetHeight) / 2));
			if( config.position === "top" ) box.style.top = "-3px";
			else box.style.top = y + 'px';

			box.style.left = x + 'px';
			//necessary for IE only;
			box.onkeydown = modal_key;

			box.focus();
			if( config.hidden ) Scheduler.component.modalbox.hide( box );

			return box;
		}

		function alertPopup( config ){ return _createBox( config, true, false ); }

		function confirmPopup( config ){ return _createBox( config, true, true ); }

		function boxPopup( config ){ return _createBox( config ); }

		function box_params(text, type, callback )
		{
			if( typeof text !== "object" )
			{
				if( typeof type === "function" )
				{
					callback = type;
					type = "";
				}
				text = { text : text, type : type, callback : callback };
			}
			return text;
		}

		function params(text, type, expire, id )
		{
			if( typeof text !== "object" ) text = { text : text, type : type, expire : expire, id : id };
			text.id = text.id || t.uid();
			text.expire = text.expire || t.expire;
			return text;
		}

		//--------------------------------------------------;

		Scheduler.component.alert = function()
		{
			var text = box_params.apply( this, arguments );
				text.type = text.type || "confirm";
			return alertPopup( text );
		};
		Scheduler.component.confirm = function()
		{
			var text = box_params.apply( this, arguments );
				text.type = text.type || "alert";
			return confirmPopup( text );
		};
		Scheduler.component.modalbox = function()
		{
			var text = box_params.apply( this, arguments );
				text.type = text.type || "alert";
			return boxPopup( text );
		};
		Scheduler.component.modalbox.hide = function( node )
		{
			while( node && node.getAttribute && !node.getAttribute( "sdrbox" ) )
				node = node.parentNode;

			if( node )
			{
				node.parentNode.removeChild( node );
				modality( false );
			}
		};

		//--------------------------------------------------;

		var t = Scheduler.component.message = function( text, type, expire, id )
		{
			text = params.apply( this, arguments );
			text.type = text.type || "info";

			var subtype = text.type.split( "-" )[ 0 ];
			switch( subtype )
			{
				case "alert" : return alertPopup( text );
				case "confirm" : return confirmPopup( text );
				case "modalbox" : return boxPopup( text );
				default : return info( text );
			}
		};

		t.seed = ( new Date() ).valueOf();
		t.uid = function(){ return t.seed++; };
		t.expire = 4000;
		t.keyboard = true;
		t.position = "top";
		t.pull = {};
		t.timers = {};

		t.hideAll = function(){ for( var key in t.pull ) t.hide( key ); };

		t.hide = function( id )
		{
			var obj = t.pull[ id ];
			if( obj && obj.parentElement )
			{
				setTimeout(function(){
					obj.parentElement.removeChild( obj );
					obj = null;
				}, 2000 );
				obj.className += " hidden";

				if( t.timers[ id ] ) clearTimeout( t.timers[ id ] );
				delete t.pull[ id ];
			}
		};
	})();

	Scheduler.componentError.catchError("LoadXML", function( a, b, c )
	{
		var message = c[ 0 ].responseText;
		switch( scheduler.config.ajax_error)
		{
			case "alert" : alert( message ); break;
			case "console" : console.log( message ); break;
			default : break;
		}
	});

	/**
	 * @property
	 */
	Scheduler.scheduler = Scheduler.getSchedulerInstance();

	return Scheduler;
});